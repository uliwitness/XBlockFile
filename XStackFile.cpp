/*	***************************************************************************	PROJECT:	XStackFile		FILE:		XStackFile.cpp		PURPOSE:	Stack file class			COPYRIGHT:	(C) Copyright 2000 by M. Uli Kusterer, all rights reserved.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness		REVISIONS:		2000-07-07	UK		Created.					************************************************************************ */#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */#include	"XStackFile.h"#pragma mark [Globals]/* --------------------------------------------------------------------------------	Globals/Static Variables:   ----------------------------------------------------------------------------- */// Put these li'l critters here.#pragma mark -#pragma mark [Init/Kill]/* --------------------------------------------------------------------------------	GetStackByID:		Get a reference to a stack which can then be further manipulated.				This first retrieves the stack list block from its block file and then		fetches the appropriate stack block from that block.		TAKES:		theID	-	ID of the stack.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-10-01	UK		Added 'create' parameter.		2000-07-08	UK		Created.   ----------------------------------------------------------------------------- */XSFStackRef	XStackFile::GetStackByID( XBlockID theID, bool create ){	XBlockEntry*		vStackListBlock;	XSFStackRef			vFoundStack;	XBlockOffset		vDummy = 0;		vStackListBlock = mBlockFile.GetBlockEntry( STACK_LIST_BLOCK_ID );	if( vStackListBlock == NULL )	{		if( create )			vStackListBlock = mBlockFile.SetBlock( STACK_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vStackListBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetStackByID", "block list missing from file." );	}		vFoundStack = vStackListBlock->GetBlockEntry( theID );	if( vFoundStack == NULL && create )	// Doesn't exist yet and we're supposed to create one.		vFoundStack = mBlockFile.AddSubBlock( vStackListBlock, theID, &vDummy, sizeof(vDummy) );		return vFoundStack;}/* --------------------------------------------------------------------------------	GetStackByNum:		Get a reference to a stack which can then be further manipulated.				This first retrieves the stack list block from its block file and then		fetches the appropriate stack block from that block.		TAKES:		theNum		-	Number of the stack.		GIVES:		XSFStackRef	-	Reference to the stack to get. NULL if it couldn't be						found.		REVISIONS:		2000-11-19	UK		Created based on GetStackByID.   ----------------------------------------------------------------------------- */XSFStackRef	XStackFile::GetStackByNum( unsigned long theNum ){	XBlockEntry*		vStackListBlock;	XSFStackRef			vFoundStack;		vStackListBlock = mBlockFile.GetBlockEntry( STACK_LIST_BLOCK_ID );	if( vStackListBlock == NULL )		return NULL;		vFoundStack = vStackListBlock->GetIndBlockEntry( theNum );	return vFoundStack;}/* --------------------------------------------------------------------------------	CountStacks:		Return the number of stacks in this file.		TAKES:		-		GIVES:		unsigned long	-	Number of stacks.		REVISIONS:		2000-11-19	UK		Created based on GetStackByNum.   ----------------------------------------------------------------------------- */unsigned long	XStackFile::CountStacks(){	XBlockEntry*		vStackListBlock;		vStackListBlock = mBlockFile.GetBlockEntry( STACK_LIST_BLOCK_ID );	if( vStackListBlock == NULL )		return 0;		return vStackListBlock->CountSubBlocks();}/* --------------------------------------------------------------------------------	GetStarByID:		Get a reference to a star (data fork resource) which can then be further		manipulated.				This first retrieves the resource list block from its block file and then		fetches the appropriate sub block from that block.		TAKES:		theType	-	The type of the star (e.g. image, report, sound ...)		theID	-	ID of the star.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-10-14	UK		Created.   ----------------------------------------------------------------------------- */XSFStarRef	XStackFile::GetStarByID( XSFStarType theType, XBlockID theID, bool create ){	XBlockEntry*		vStackListBlock,						*vTypeListBlock;	XSFStarRef			vFoundStack;	XBlockOffset		vDummy = 0;		vStackListBlock = mBlockFile.GetBlockEntry( RESOURCE_LIST_BLOCK_ID );	if( vStackListBlock == NULL )	{		if( create )			vStackListBlock = mBlockFile.SetBlock( RESOURCE_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vStackListBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetStarByID", "block list missing from file." );	}		vTypeListBlock = vStackListBlock->GetBlockEntry( theType );	if( vTypeListBlock == NULL && create )	// Doesn't exist yet and we're supposed to create one.		vTypeListBlock = mBlockFile.AddSubBlock( vStackListBlock, theType, &vDummy, sizeof(vDummy) );		vFoundStack = vTypeListBlock->GetBlockEntry( theID );	if( vFoundStack == NULL && create )	// Doesn't exist yet and we're supposed to create one.		vFoundStack = mBlockFile.AddSubBlock( vTypeListBlock, theID, &vDummy, sizeof(vDummy) );		return vFoundStack;}/* --------------------------------------------------------------------------------	GetStarByNum:		Get a reference to a star (data fork resource) which can then be further		manipulated.				This first retrieves the resource list block from its block file and then		fetches the appropriate sub block from that block.		TAKES:		theType		-	The type of the star (e.g. image, report, sound ...)		theNum		-	number of the star.		GIVES:		XSFStarRef	-	The star or NULL if there is no such star.		REVISIONS:		2000-11-19	UK		Created based on GetStarByID.   ----------------------------------------------------------------------------- */XSFStarRef	XStackFile::GetStarByNum( XSFStarType theType, unsigned long theNum ){	XBlockEntry*		vStackListBlock,						*vTypeListBlock;	XSFStarRef			vFoundStack;		vStackListBlock = mBlockFile.GetBlockEntry( RESOURCE_LIST_BLOCK_ID );	if( vStackListBlock == NULL )		return NULL;		vTypeListBlock = vStackListBlock->GetBlockEntry( theType );	if( vTypeListBlock == NULL )		return NULL;		vFoundStack = vTypeListBlock->GetIndBlockEntry( theNum );	return vFoundStack;}/* --------------------------------------------------------------------------------	CountStars:		Determine the number of stars of a give type in a file.				This first retrieves the resource list block from its block file and then		fetches the appropriate sub block from that block.		TAKES:		theType			-	The type of stars to count (e.g. image, report,							sound ...)		GIVES:		unsigned long	-	The number of stars.		REVISIONS:		2000-11-19	UK		Created based on GetStarByNum.   ----------------------------------------------------------------------------- */unsigned long	XStackFile::CountStars( XSFStarType theType ){	XBlockEntry			*vStackListBlock,						*vTypeListBlock;		vStackListBlock = mBlockFile.GetBlockEntry( RESOURCE_LIST_BLOCK_ID );	if( vStackListBlock == NULL )		return 0;		vTypeListBlock = vStackListBlock->GetBlockEntry( theType );	if( vTypeListBlock == NULL )		return 0;		return vTypeListBlock->CountSubBlocks();}/* --------------------------------------------------------------------------------	GetStarData:		Get a pointer to the data in a Star.		TAKES:		theStar	-	Reference to a star rerieved from GetStarByID().		outData	-	Pointer to a void* variable that will be filled by this call.					May be NULL if you only need size.		outSize	-	Pointer to a size_t variable that will be filled by this call.					May be NULL if you know the size already.		GIVES:		outData	-	Pointer to the block's data, owned by XStackFile. Do not dispose					of this!		outSize	-	Size of the pointer returned in theData.		REVISIONS:		2000-10-14	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::GetStarData( XSFStarRef theStar, void* *outData, size_t *outSize ){	if( outSize != NULL )		*outSize = theStar->GetLength();	if( outData != NULL )		(*outData) = mBlockFile.GetBlockData( theStar );}/* --------------------------------------------------------------------------------	SetStarData:		Change the contents of an existing Star.		TAKES:		theStar	-	Reference to a star rerieved from GetStarByID().		inData	-	Pointer to the data to write to the block.		inSize	-	Length of the data at the pointer inData		GIVES:		-			REVISIONS:		2000-10-14	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::SetStarData( XSFStarRef theStar, void* inData, size_t inSize ){	theStar->SetLength( inSize );	mBlockFile.StreamToBlockEntry( theStar, inData, inSize, 0 );}/* --------------------------------------------------------------------------------	GetBlockByID:		Get a reference to a root block which can then be further		manipulated.		TAKES:		theID	-	ID of the block.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		vData	-	Pointer to data to write to the block if we're creating it.					Set to NULL if you don't care.		inSize	-	Size of the data in vData. If vData is NULL this is ignored.		GIVES:		-		REVISIONS:		2000-11-13	UK		Created.   ----------------------------------------------------------------------------- */XSFBlockRef	XStackFile::GetBlockByID( XBlockID theID, void* vData,										size_t inSize, bool create ){	XBlockEntry*		vStackListBlock;	XBlockOffset		vDummy = 0;	if( vData == NULL )	{		vData = &vDummy;		inSize = sizeof(vDummy);	}		vStackListBlock = mBlockFile.GetBlockEntry( theID );	if( vStackListBlock == NULL )	{		if( create )			vStackListBlock = mBlockFile.SetBlock( theID, vData, inSize );		else			throw XSFBlockNotFoundError( __FILE__, "GetBlockByID", "Couldn't find a requested root block." );	}		return vStackListBlock;}/* --------------------------------------------------------------------------------	GetEntityBlockByID:		Get a reference to an entity's sub block which can then be further		manipulated.		TAKES:		entity	-	The entity containing the block.		theID	-	ID of the block.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		vData	-	Pointer to data to write to the block if we're creating it.					Set to NULL if you don't care.		inSize	-	Size of the data in vData. If vData is NULL this is ignored.		GIVES:		-		REVISIONS:		2000-11-16	UK		Based on GetCardByID.   ----------------------------------------------------------------------------- void	XStackFile::GetEntityBlockByID( XSFEntityRef entity, XBlockID theID,										void* *ioData, size_t *ioSize,										bool create, bool overwrite ){	XBlockEntry*		vCardListBlock;	long				vDummy = 0;		vCardListBlock = entity->GetBlockEntry( theID );	if( vCardListBlock == NULL || overwrite )	{		if( create || overwrite )			vCardListBlock = mBlockFile.AddSubBlock( entity, theID, *ioData, *ioSize );				if( vCardListBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetEntityBlockByID", "Missing sub block in entity." );	}	if( ioSize != NULL )		*ioSize = vCardListBlock->GetLength();	(*ioData) = mBlockFile.GetBlockData( vCardListBlock );}*//* --------------------------------------------------------------------------------	GetEntityBlockByID:		Get a reference to an entity's sub block which can then be further		manipulated.		TAKES:		entity	-	The entity containing the block.		theID	-	ID of the block.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		inData	-	Default data if block needs to bre created. May be NULL.		inSize	-	Size of default data in inData.		GIVES:		XSFBlockRef	-	A reference to the sub block retrieved.		REVISIONS:		2000-11-16	UK		Created.   ----------------------------------------------------------------------------- */XSFBlockRef	XStackFile::GetEntityBlockByID( XSFEntityRef entity, XBlockID theID,											void* inData, size_t inSize, bool create ){	XBlockEntry*		vCardListBlock;	long				vDummy = 0;		if( inData == NULL )	{		inData = &vDummy;		inSize = sizeof(vDummy);	}		vCardListBlock = entity->GetBlockEntry( theID );	if( vCardListBlock == NULL && create )		vCardListBlock = mBlockFile.AddSubBlock( entity, theID, inData, inSize );			if( vCardListBlock == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetEntityBlockByID", "Missing sub block in entity." );		return vCardListBlock;}/* --------------------------------------------------------------------------------	GetEntityBlockByNum:		Get a reference to an entity's sub block which can then be further		manipulated.		TAKES:		entity	-	The entity containing the block.		theNum	-	Number of the block.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		vData	-	Pointer to data to write to the block if we're creating it.					Set to NULL if you don't care.		inSize	-	Size of the data in vData. If vData is NULL this is ignored.		GIVES:		-		REVISIONS:		2000-11-19	UK		Based on GetEntityBlockByID.   ----------------------------------------------------------------------------- */void	XStackFile::GetEntityBlockByNum( XSFEntityRef entity, unsigned long theNum,										void* *ioData, size_t *ioSize,										bool overwrite ){	XBlockEntry*		vCardListBlock;	long				vDummy = 0;		vCardListBlock = entity->GetIndBlockEntry( theNum );	if( overwrite )		vCardListBlock = mBlockFile.AddSubBlock( entity, vCardListBlock->mId, *ioData, *ioSize );	if( vCardListBlock == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetEntityBlockByNum", "Missing sub block in entity." );	if( ioSize != NULL )		*ioSize = vCardListBlock->GetLength();	(*ioData) = mBlockFile.GetBlockData( vCardListBlock );}/* --------------------------------------------------------------------------------	CountEntityBlocks:		Determine the number of blocks of an entity.		TAKES:		entity	-	The entity whose blocks we are to count.		GIVES:		-		REVISIONS:		2000-11-19	UK		Based on GetEntityBlockByNum.   ----------------------------------------------------------------------------- */unsigned long	XStackFile::CountEntityBlocks( XSFEntityRef entity ){	return entity->CountSubBlocks();}/* --------------------------------------------------------------------------------	GetBlockData:		Get a pointer to the data in a root block.		TAKES:		theStar	-	Reference to a block rerieved from GetBlockByID().		outData	-	Pointer to a void* variable that will be filled by this call.					May be NULL if you only need size.		outSize	-	Pointer to a size_t variable that will be filled by this call.					May be NULL if you know the size already.		GIVES:		outData	-	Pointer to the block's data, owned by XStackFile. Do not dispose					of this!		outSize	-	Size of the pointer returned in theData.		REVISIONS:		2000-11-13	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::GetBlockData( XSFBlockRef theStar, void* *outData, size_t *outSize ){	if( outSize != NULL )		*outSize = theStar->GetLength();	if( outData != NULL )		(*outData) = mBlockFile.GetBlockData( theStar );}/* --------------------------------------------------------------------------------	SetBlockData:		Change the contents of an existing root block.		TAKES:		theStar	-	Reference to a block rerieved from GetBlockByID().		inData	-	Pointer to the data to write to the block.		inSize	-	Length of the data at the pointer inData		GIVES:		-			REVISIONS:		2000-11-13	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::SetBlockData( XSFBlockRef theBlock, void* inData, size_t inSize ){	theBlock->SetLength( inSize );	mBlockFile.StreamToBlockEntry( theBlock, inData, inSize, 0 );}/* --------------------------------------------------------------------------------	GetStructBlockData:		Specialized variant of GetBlockData/SetBlockData() that knows about the		data type it is supposed to retrieve and does endian conversion.		TAKES:		ioData		-	Pointer to a variable with the value to use when (over)writing.		inTemplate	-	A template describing the layout of the data structure.		GIVES:		ioData		-	The variable pointed to by this is set to the value retrieved						from the file, all properly endian-swapped.		REVISIONS:		2000-10-11	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::GetStructBlockData( XBlockID blockID, void* ioData, const SftType inTemplate[],										bool create, bool overwrite ){	char*			boxPtr;	unsigned long	vSize;	void*			vDataCopy = NULL;	XSFBlockRef		vTheBlock;		// Make copy of our data that we can swap:	vSize = mBlockFile.GetStructSize( inTemplate );	// FIX ME! Might speed up things to cache these.	vDataCopy = malloc(vSize);	if( vDataCopy == NULL )		throw MemoryError( __FILE__, "GetStructBlockData", "Can't allocate buffer for endian conversion." );	try {		memcpy( vDataCopy, ioData, vSize );		mBlockFile.SwapStruct( vDataCopy, inTemplate );		boxPtr = (char*)vDataCopy;			// Get property with user parameters:		vTheBlock = GetBlockByID( blockID, boxPtr, vSize, create );		if( overwrite )			SetBlockData( vTheBlock, boxPtr, vSize );		GetBlockData( vTheBlock, &boxPtr, &vSize );	}	catch( exception& err )	{		free( vDataCopy );		throw;	}	free( vDataCopy );	// Copy out data again, swapping it if needed:	memcpy( ioData, boxPtr, vSize );	// FIX ME! Needs to error on larger returned than passed!	mBlockFile.SwapStruct( ioData, inTemplate );}/* --------------------------------------------------------------------------------	GetCardByID:		Get a reference to a card which can then be further manipulated.		TAKES:		stack	-	The stack the card belongs to.		theID	-	ID of the card to get.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-10-01	UK		Added 'create' parameter.		2000-07-08	UK		Created.   ----------------------------------------------------------------------------- */XSFCardRef	XStackFile::GetCardByID( XSFStackRef stack, XBlockID theID, bool create ){	XBlockEntry*		vCardListBlock;	XSFCardRef			vFoundCard;	long				vDummy = 0;		vCardListBlock = stack->GetBlockEntry( STACK_CARD_LIST_BLOCK_ID );	if( vCardListBlock == NULL )	{		if( create )			vCardListBlock = mBlockFile.AddSubBlock( stack, STACK_CARD_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vCardListBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetCardByID", "block list missing from file." );	}		vFoundCard = vCardListBlock->GetBlockEntry( theID );	if( vFoundCard == NULL && create )		vFoundCard = mBlockFile.AddSubBlock( vCardListBlock, theID, &vDummy, sizeof(vDummy) );		return vFoundCard;}/* --------------------------------------------------------------------------------	GetCardByNum:		Get a reference to a card which can then be further manipulated.		TAKES:		stack	-	The stack the card belongs to.		theNum	-	Number of the card to get.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		GIVES:		XSFCardRef	-	The card. 		REVISIONS:		2000-11-19	UK		Created based on GetCardByID.   ----------------------------------------------------------------------------- */XSFCardRef	XStackFile::GetCardByNum( XSFStackRef stack, unsigned long theNum ){	XBlockEntry*		vCardListBlock;	XSFCardRef			vFoundCard;		vCardListBlock = stack->GetBlockEntry( STACK_CARD_LIST_BLOCK_ID );	if( vCardListBlock == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetCardByNum", "block list missing from file." );		vFoundCard = vCardListBlock->GetIndBlockEntry( theNum );	if( vFoundCard == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetCardByNum", "couldn't find card of that number." );		return vFoundCard;}/* --------------------------------------------------------------------------------	CountStackCards:		Return number of cards in a stack.		TAKES:		stack	-	The stack to count.		GIVES:		unsigned long	-	Number of cards.		REVISIONS:		2000-11-19	UK		Created based on GetCardByNum.   ----------------------------------------------------------------------------- */unsigned long	XStackFile::CountStackCards( XSFStackRef stack ){	XBlockEntry*		vCardListBlock;		vCardListBlock = stack->GetBlockEntry( STACK_CARD_LIST_BLOCK_ID );	if( vCardListBlock == NULL )		return 0;		return vCardListBlock->CountSubBlocks();}/* --------------------------------------------------------------------------------	GetBkgndByID:		Get a reference to a background which can then be further manipulated.		TAKES:		stack	-	the stack the background belongs to.		theID	-	ID of the background to get.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-10-01	UK		Added 'create' parameter.		2000-07-08	UK		Created.   ----------------------------------------------------------------------------- */XSFBkgndRef	XStackFile::GetBkgndByID( XSFStackRef stack, XBlockID theID, bool create ){	XBlockEntry*		vBkgndListBlock;	XSFBkgndRef			vFoundBkgnd;	long				vDummy = 0;		vBkgndListBlock = stack->GetBlockEntry( STACK_BKGND_LIST_BLOCK_ID );	if( vBkgndListBlock == NULL )	{		if( create )			vBkgndListBlock = mBlockFile.AddSubBlock( stack, STACK_BKGND_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vBkgndListBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetBkgndByID", "block list missing from file." );	}		vFoundBkgnd = vBkgndListBlock->GetBlockEntry( theID );	if( vFoundBkgnd == NULL && create )		vFoundBkgnd = mBlockFile.AddSubBlock( vBkgndListBlock, theID, &vDummy, sizeof(vDummy) );		return vFoundBkgnd;}/* --------------------------------------------------------------------------------	GetBkgndByNum:		Get a reference to a background which can then be further manipulated.		TAKES:		stack	-	the stack the background belongs to.		theNum	-	Number of the background to get.		create	-	Set this to TRUE if you want a block created for you when					there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-10-01	UK		Created based on GetBkgndByID.   ----------------------------------------------------------------------------- */XSFBkgndRef	XStackFile::GetBkgndByNum( XSFStackRef stack, unsigned long theNum ){	XBlockEntry*		vBkgndListBlock;	XSFBkgndRef			vFoundBkgnd;		vBkgndListBlock = stack->GetBlockEntry( STACK_BKGND_LIST_BLOCK_ID );	if( vBkgndListBlock == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetBkgndByNum", "block list missing from file." );		vFoundBkgnd = vBkgndListBlock->GetIndBlockEntry( theNum );	if( vFoundBkgnd == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetBkgndByNum", "couldn't find background of that number." );		return vFoundBkgnd;}/* --------------------------------------------------------------------------------	CountStackBkgnds:		Return the number of bgs in a stack.		TAKES:		stack	-	the stack to count.		GIVES:		-		REVISIONS:		2000-11-19	UK		Created based on GetBkgndByNum.   ----------------------------------------------------------------------------- */unsigned long	XStackFile::CountStackBkgnds( XSFStackRef stack ){	XBlockEntry*		vBkgndListBlock;		vBkgndListBlock = stack->GetBlockEntry( STACK_BKGND_LIST_BLOCK_ID );	if( vBkgndListBlock == NULL )		return 0;		return vBkgndListBlock->CountSubBlocks();}/* --------------------------------------------------------------------------------	GetPartByID:		Get a reference to a part which can then be further manipulated.		TAKES:		cardOrBg	-	the card or background the part belongs to.						Note that this does not resolve unshared properties.		theID		-	ID of the part to get.		create		-	Set this to TRUE if you want a block created for you when						there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-10-01	UK		Added 'create' parameter.		2000-07-08	UK		Created.   ----------------------------------------------------------------------------- */XSFPartRef	XStackFile::GetPartByID( XSFLayerRef cardOrBg, XBlockID theID, bool create ){	XBlockEntry*		vPartListBlock;	XSFPartRef			vFoundPart;	long				vDummy = 0;		vPartListBlock = cardOrBg->GetBlockEntry( LAYER_PART_LIST_BLOCK_ID );	if( vPartListBlock == NULL )	{		if( create )			vPartListBlock = mBlockFile.AddSubBlock( cardOrBg, LAYER_PART_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vPartListBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetPartByID", "part list missing from file." );	}		vFoundPart = vPartListBlock->GetBlockEntry( theID );	if( vFoundPart == NULL && create )		vFoundPart = mBlockFile.AddSubBlock( vPartListBlock, theID, &vDummy, sizeof(vDummy) );		if( vFoundPart == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetPartByID", "part not found." );		return vFoundPart;}/* --------------------------------------------------------------------------------	GetPartByNum:		Get a reference to a part which can then be further manipulated.		TAKES:		cardOrBg	-	the card or background the part belongs to.						Note that this does not resolve unshared properties.		theNum		-	Number of the part to get.		create		-	Set this to TRUE if you want a block created for you when						there is none. Defaults to FALSE.		GIVES:		-		REVISIONS:		2000-11-19	UK		Created based on GetPartByID.   ----------------------------------------------------------------------------- */XSFPartRef	XStackFile::GetPartByNum( XSFLayerRef cardOrBg, unsigned long theNum ){	XBlockEntry*		vPartListBlock;	XSFPartRef			vFoundPart;		vPartListBlock = cardOrBg->GetBlockEntry( LAYER_PART_LIST_BLOCK_ID );	if( vPartListBlock == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetPartByNum", "part list missing from file." );		vFoundPart = vPartListBlock->GetIndBlockEntry( theNum );	if( vFoundPart == NULL )		throw XSFBlockNotFoundError( __FILE__, "GetPartByNum", "couldn't find part of this number." );		return vFoundPart;}/* --------------------------------------------------------------------------------	CountLayerParts:		Return the number of parts on a given card or background.		TAKES:		cardOrBg	-	the card or background the part belongs to.						Note that this does not resolve unshared properties.		GIVES:		-		REVISIONS:		2000-11-19	UK		Created based on GetPartByNum.   ----------------------------------------------------------------------------- */unsigned long	XStackFile::CountLayerParts( XSFLayerRef cardOrBg ){	XBlockEntry*		vPartListBlock;		vPartListBlock = cardOrBg->GetBlockEntry( LAYER_PART_LIST_BLOCK_ID );	if( vPartListBlock == NULL )		return 0;		return vPartListBlock->CountSubBlocks();}/* --------------------------------------------------------------------------------	GetEntityRefCon:		The entity refCon is used to keep RAM objects associated with their blocks		on disk.		TAKES:		entity	-	A reference to the entity's entry in the file.		GIVES:		void*	-	A pointer to the refCon you stored, typically a RAM entity.					NULL if none was specified.		REVISIONS:		2000-11-15	UK		Created.   ----------------------------------------------------------------------------- */void*	XStackFile::GetEntityRefCon( XSFEntityRef entity ){	return entity->GetRefCon();}/* --------------------------------------------------------------------------------	SetEntityRefCon:		The entity refCon is used to keep RAM objects associated with their blocks		on disk.		TAKES:		entity	-	A reference to the entity's entry in the file.		rc		-	The new value for the refCon. Use NULL to mean don't use					any refCon.		GIVES:		-		REVISIONS:		2000-11-15	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::SetEntityRefCon( XSFEntityRef entity, void* rc ){	entity->SetRefCon( rc );}/* --------------------------------------------------------------------------------	GetUserProperty:		Get a user property from any entity.				If you set the "create" parameter to TRUE, this function will create the		property and assign it the data passed in in ioData and ioSize. But be		aware that on output it will set ioData to point at the data in the fixed		size property block, not at the data you passed in.		TAKES:		entity		-	Any entity from which you want to get a property.		propName	-	The name of the property to get.		ioData		-	Pointer to a pointer to some data to use as a default for						the property if you set <create> to TRUE.		ioSize		-	Pointer to a variable containing the size of the property						data you expect if you know it (required for fixed size						properties). For variable sized properties this is ignored.		create		-	Set this to TRUE if you want a block created for you when						there is none. Defaults to FALSE.		overwrite	-	Set this to TRUE to force the new data to be written to the						block. This is useful for changing properties.		idx			-	Pass a value != 0 here to get a block by index. This						overrides any names passed in. The property name will be						copied to the parameter propName. If the index is bigger						than the number of property blocks available, this will						set propName to an empty string.		GIVES:		ioData		-	A pointer to the data of the property.		ioSize		-	Size of the data to which the pointer was returned.		propName	-	If idx != 0, this will be overwritten with the property						name.		REVISIONS:		2000-11-25	UK		Created based on GetProperty.   ----------------------------------------------------------------------------- */void	XStackFile::GetUserProperty( XSFEntityRef entity, char* propName,									void* *ioData, XBlockOffset *ioSize,									bool create, bool overwrite, XBlockOffset idx ){	XBlockEntry		*vPropList,					*vPropertyBlock;	XBlockOffset	vDummy = 0;	XBlockOffset	vDataOffset = 0;	// Impossible value, synonymous to "no property found".	XBlockID		vBlockID;		// Fetch block grouping together all property blocks:	vPropList = entity->GetBlockEntry( USER_PROPERTY_LIST_BLOCK_ID );	if( vPropList == NULL )	{		if( create )			vPropList = mBlockFile.AddSubBlock( entity, USER_PROPERTY_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vPropList == NULL )		{			if( idx != 0 )			{				propName[0] = 0;				return;			}			else				throw XSFBlockNotFoundError( __FILE__, "GetUserProperty", "property list missing from file." );		}	}		XBlockOffset		vSBCount = vPropList->CountSubBlocks(),						x;	unsigned char		len;	char				vPropNameStr[256];	// FIX ME! Size limit on property names!		if( idx == 0 )	{		// Loop over blocks, get their names and check those against the name passed in:		for( x = 1; x <= vSBCount; x++ )		{			vPropertyBlock = vPropList->GetIndBlockEntry( x );			if( vPropertyBlock == NULL )				throw logic_error( "GetUserProperty - We're messed up! Couldn't get one of the user property blocks." );			mBlockFile.StreamFromBlockEntry( vPropertyBlock, &len, sizeof(char), 0 );			mBlockFile.StreamFromBlockEntry( vPropertyBlock, vPropNameStr, len, 1 );			vPropNameStr[len] = 0;	// Zero-terminate property name.						if( strcmp( vPropNameStr, propName ) == 0 )		// Is the one we were looking for?			{				vDataOffset = len +1;	// Make sure we know how to skip name later.				vBlockID = vPropertyBlock->mId;	// Remember ID so we can overwrite if needed.				break;			}		}	}	else	// Fetch block by index.	{		vPropertyBlock = vPropList->GetIndBlockEntry( idx );		if( vPropertyBlock == NULL )	// No more blocks? Return empty string as name.		{			propName[0] = 0;			return;		}		// Copy property name to propName:		mBlockFile.StreamFromBlockEntry( vPropertyBlock, &len, sizeof(char), 0 );		mBlockFile.StreamFromBlockEntry( vPropertyBlock, propName, len, 1 );		propName[len] = 0;				// Zero-terminate property name.		vDataOffset = len +1;			// Make sure we know how to skip name later.		vBlockID = vPropertyBlock->mId;	// Remember ID so we can overwrite if needed.	}		if( vDataOffset == 0 && create )	// Block not found? Generate unique ID if we're supposed to create a new one.	{		XBlockEntry*	vEntry = (XBlockEntry*) 1;	// Just so we don't terminate right away.				// Loop until we find an unused ID:		for( x = 1; vEntry != NULL; x++ )	// Must start at 1, zero is used for turning off indices.			vEntry = vPropList->GetBlockEntry( x );				// Remember unused ID for use as block ID:		vBlockID = x;	}		if( vDataOffset == 0 || overwrite )	{		if( create || overwrite )		{			vPropertyBlock = mBlockFile.AddSubBlock( vPropList, vBlockID, &vDummy, sizeof(vDummy) );			len = strlen(propName);			mBlockFile.StreamToBlockEntry( vPropertyBlock, &len, 1, 0 );				// Write down length byte.			mBlockFile.StreamToBlockEntry( vPropertyBlock, propName, len, 1 );			// Write down property name.			mBlockFile.StreamToBlockEntry( vPropertyBlock, *ioData, *ioSize, len+1 );	// Write down property data.			vDataOffset = len+1;	// Remember how much to skip to get at data.		}		if( vPropertyBlock == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetUserProperty", "user property block missing from file." );	}	if( ioSize != NULL )		*ioSize = vPropertyBlock->GetLength() -vDataOffset;		// Add to pointer and return it (remember, ioData is a char**!):	(*ioData) = (char*) mBlockFile.GetBlockData( vPropertyBlock );	(*(unsigned long*)ioData) += vDataOffset;	// Need to cast, can't add to pointers in CW.}/* --------------------------------------------------------------------------------	GetProperty:		Get a fixed or flexible size property from any entity.				If you set the "create" parameter to TRUE, this function will create the		property and assign it the data passed in in ioData and ioSize. But be		aware that on output it will set ioData to point at the data in the fixed		size property block, not at the data you passed in.		TAKES:		entity		-	Any entity from which you want to get a property.		propID		-	ID of the property to get.		ioData		-	Pointer to a pointer to some data to use as a default for						the property if you set <create> to TRUE.		ioSize		-	Pointer to a variable containing the size of the property						data you expect if you know it (required for fixed size						properties). For variable sized properties this is ignored.		create		-	Set this to TRUE if you want a block created for you when						there is none. Defaults to FALSE.		overwrite	-	Set this to TRUE to force the new data to be written to the						block. This is useful for changing properties.		GIVES:		ioData		-	A pointer to the data of the property.		ioSize		-	Size of the data to which the pointer was returned.		REVISIONS:		2000-11-27	MR		Added Endian support for offsets.		2000-10-09	UK		Finished supporting overwriting existing blocks.		2000-10-06	UK		Implemented creating fixed-size properties, added							ioData parameter.		2000-10-01	UK		Added 'create' parameter.		2000-07-08	UK		Created.   ----------------------------------------------------------------------------- */void	XStackFile::GetProperty( XSFEntityRef entity, long propID, void* *ioData, long *ioSize,								bool create, bool overwrite ){	XBlockEntry		*vPropList,					*vFixedPropTable,					*vPropertyBlock;	XBlockOffset	vDummy = 0;	XBlockOffset*	vDummyPtr = &vDummy;		// Fetch block grouping together all property blocks:	vPropList = entity->GetBlockEntry( PROPERTY_LIST_BLOCK_ID );	if( vPropList == NULL )	{		if( create )			vPropList = mBlockFile.AddSubBlock( entity, PROPERTY_LIST_BLOCK_ID, &vDummy, sizeof(vDummy) );				if( vPropList == NULL )			throw XSFBlockNotFoundError( __FILE__, "GetProperty", "property list missing from file." );	}		if( propID >= DYN_PROP_START_ID )	// Dynamic size property:	{		vPropertyBlock = vPropList->GetBlockEntry( propID );	// Just get its data from its block.		if( vPropertyBlock == NULL || overwrite )		{			if( create || overwrite )				vPropertyBlock = mBlockFile.AddSubBlock( vPropList, propID, *ioData, *ioSize );						if( vPropertyBlock == NULL )				throw XSFBlockNotFoundError( __FILE__, "GetProperty", "dynamic size property block missing from file." );		}		if( ioSize != NULL )			*ioSize = vPropertyBlock->GetLength();		(*ioData) = mBlockFile.GetBlockData( vPropertyBlock );	}	else	// Fixed size property:	{		size_t		vOffset,					vDataOffset,					vOldLength;				// Get offset table:		vFixedPropTable = vPropList->GetBlockEntry( FIXED_SIZE_PROP_TABLE_BLOCK_ID );		if( vFixedPropTable == NULL )		{			if( create )			{				vDummy = mBlockFile.SwapLong( FIXED_ENTRY_UNUSED );				vFixedPropTable = mBlockFile.AddSubBlock( vPropList, FIXED_SIZE_PROP_TABLE_BLOCK_ID, &vDummy, sizeof(vDummy) );			}						if( vFixedPropTable == NULL )				throw XSFBlockNotFoundError( __FILE__, "GetProperty", "fixed size property offset table missing from file." );		}				// Read offset from table:		vOffset = propID * sizeof(long);		vOldLength = vFixedPropTable->GetLength();		if( vOldLength < (vOffset +sizeof(long)) )		{			if( create )	// We are supposed to create/enlarge when needed?			{				long		defaultVal = FIXED_ENTRY_UNUSED;								vFixedPropTable->SetLength( vOffset +sizeof(long) );				while( vOldLength < vOffset )				{					defaultVal = mBlockFile.SwapLong( defaultVal );	// Make sure endian conversion is performed if needed.					mBlockFile.StreamToBlockEntry( vFixedPropTable,										&defaultVal, sizeof(defaultVal),										vOldLength );					vOldLength += sizeof(defaultVal);				}				vDataOffset = FIXED_ENTRY_UNUSED;	// Make sure below knows they need to add data.			}			else				throw XSFBlockNotFoundError( __FILE__, "XStackFile", "No entry for this property in object." );		}		else		{			mBlockFile.StreamFromBlockEntry( vFixedPropTable, &vDataOffset, sizeof(long), vOffset );			vDataOffset = mBlockFile.SwapLong( vDataOffset );		// Make sure endian conversion is performed if needed.		}				size_t		vWriteDOffs;				// Get property data block:		vPropertyBlock = vPropList->GetBlockEntry( FIXED_SIZE_PROPERTIES_BLOCK_ID );		if( vPropertyBlock == NULL )		{			/* If the data block doesn't exist, we must have just created an entry in the offset				table for this block. We can just create the block and set its data to what was				passed in. Then we store the offset of zero in the table. */			if( create )			{				vPropertyBlock = mBlockFile.AddSubBlock( vPropList, FIXED_SIZE_PROPERTIES_BLOCK_ID,															(*ioData), (*ioSize) );				vDataOffset = 0;								// Enter new offset in offset table:				vWriteDOffs = mBlockFile.SwapLong( vDataOffset );		// Make sure endian conversion is performed if needed.				mBlockFile.StreamToBlockEntry( vFixedPropTable,												&vWriteDOffs, sizeof(vWriteDOffs),												vOffset );			}						if( vPropertyBlock == NULL )				throw XSFBlockNotFoundError( __FILE__, "GetProperty", "fixed size property data block missing from file." );		}		else		{			size_t		vNewSize;						if( vDataOffset == FIXED_ENTRY_UNUSED )			{				if( create )				{					/* Make sure code below appends data to end of data block:						This works because the offset lies just at the end of						the block, i.e. the block is now too small to hold						the data. The code below will thus automatically						enlarge the block and write the defaults passed in						to the block. */					vDataOffset = vPropertyBlock->GetLength();										// Enter new offset in offset table:					vWriteDOffs = mBlockFile.SwapLong( vDataOffset );		// Make sure endian conversion is performed if needed.					mBlockFile.StreamToBlockEntry( vFixedPropTable,													&vWriteDOffs, sizeof(vWriteDOffs),													vOffset );				}				else					throw XSFBlockNotFoundError( __FILE__, "GetProperty", "Property has no value assigned to it." );			}						// Resize block:			vNewSize = vDataOffset +(*ioSize);			if( vDataOffset > vNewSize || overwrite )			{				if( create || overwrite )				{					if( vDataOffset > vNewSize )						vPropertyBlock->SetLength( vNewSize );					// NO ENDIAN ISSUE : writing raw data					mBlockFile.StreamToBlockEntry( vPropertyBlock,		// Write default to block.													(*ioData), (*ioSize),													vDataOffset );				}				else					throw XSFBlockNotFoundError( __FILE__, "GetProperty", "Offset of fixed size property extends past end of data block." );			}		}				// Add to pointer and return it (remember, ioData is a char**!):		(*ioData) = (char*) mBlockFile.GetBlockData( vPropertyBlock );		(*(unsigned long*)ioData) += vDataOffset;	// Need to cast, can't add to pointers in CW.	}}/* --------------------------------------------------------------------------------	GetShortProperty:		Specialized variant of GetProperty() that knows about the data type it is		supposed to retrieve and does endian conversion. All parameters with the		same names as those of GetProperty() have the same meanings.		TAKES:		box		-	Pointer to a variable with the value to use when (over)writing.		GIVES:		box		-	The variable pointed to by this is set to the value retrieved					from the file, all properly endian-swapped.		REVISIONS: 		2000-11-11	MR		added VisualC support		2000-10-11	UK		Created.  ----------------------------------------------------------------------------- */void	XStackFile::GetShortProperty( XSFEntityRef entity, long propID, short* box,									bool create, bool overwrite ){	short	changeableBox;		short*	boxPtr = &changeableBox;	long	vSize = sizeof(short);		// Copy user's number to ours, doing endian conversion if needed:	changeableBox = mBlockFile.SwapShort(*box);		// Get property with user parameters: (VC++ requires us to cast to void**)	GetProperty( entity, propID, (void**) &boxPtr, &vSize, create, overwrite );	// Copy pointer to data returned by GetProperty() to user's number, endian convrting if needed.	*box = mBlockFile.SwapShort(*boxPtr);}/* --------------------------------------------------------------------------------	GetLongProperty:		Specialized variant of GetProperty() that knows about the data type it is		supposed to retrieve and does endian conversion. All parameters with the		same names as those of GetProperty() have the same meanings.		TAKES:		box		-	Pointer to a variable with the value to use when (over)writing.		GIVES:		box		-	The variable pointed to by this is set to the value retrieved					from the file, all properly endian-swapped.		REVISIONS: 		2000-11-11	MR		added VisualC support		2000-10-11	UK		Created.  ----------------------------------------------------------------------------- */void	XStackFile::GetLongProperty( XSFEntityRef entity, long propID, long* box,										bool create, bool overwrite ){	long	changeableBox;		long*	boxPtr = &changeableBox;	long	vSize = sizeof(long);		// Copy user's number to ours, doing endian conversion if needed:	changeableBox = mBlockFile.SwapLong(*box);		// Get property with user parameters: (Stupid VC++ requires us to cast to void**)	GetProperty( entity, propID, (void**) &boxPtr, &vSize, create, overwrite );	// Copy pointer to data returned by GetProperty() to user's number, endian convrting if needed.	*box = mBlockFile.SwapLong(*boxPtr);}/* --------------------------------------------------------------------------------	GetStructListProperty:		Specialized variant of GetStructProperty() that retrieves data from a block		that consists of a long counter followed by that many times data in the		format specified by inTemplate.		TAKES:		ioData		-	Pointer to a variable with the value to use when (over)writing.		inTemplate	-	A template describing the layout of one entry.		GIVES:		ioData		-	The variable pointed to by this is set to the value retrieved						from the file, all properly endian-swapped.		REVISIONS: 		2000-11-11	MR		added VisualC support		2000-10-11	UK		Created.  ----------------------------------------------------------------------------- */void	XStackFile::GetStructListProperty( XSFEntityRef entity, long propID,										void* ioData, const SftType inTemplate[],										bool create, bool overwrite ){	char*	boxPtr;	long	vSize, vBlockSize;	void*	vDataCopy = NULL;	long	vCount;		// Make copy of our data that we can swap:	vSize = mBlockFile.GetStructSize( inTemplate );	// FIX ME! Might speed up things to cache these.	vCount = (*(long*)ioData);	vDataCopy = malloc(vSize * vCount);	if( vDataCopy == NULL )		throw MemoryError( __FILE__, "GetStructListProperty", "Couldn't allocate buffer for struct swapping." );	try	{			memcpy( vDataCopy, ioData, vSize * vCount );		boxPtr = (char*) vDataCopy;		(*(long*)boxPtr) = mBlockFile.SwapLong( (*(long*)boxPtr) );		// Swap length long.		boxPtr += sizeof(long);				for( ; vCount > 0; vCount-- )	// Swap each entry:		{			mBlockFile.SwapStruct( boxPtr, inTemplate );			boxPtr += vSize;		}				// Do actual property get/set call:		boxPtr = (char*) vDataCopy;			vBlockSize = vSize * vCount +sizeof(long);		// Get property with user parameters: (Stupid VC++ requires cast to void**)		GetProperty( entity, propID, (void**) &boxPtr, &vBlockSize, create, overwrite );	}	catch( exception& err )	{		free( vDataCopy );		throw;	}	free( vDataCopy );	// Copy out data again, swapping it if needed:	memcpy( ioData, boxPtr, vBlockSize );	// FIX ME! Needs to error on larger returned than passed!	boxPtr = (char*) ioData;	vCount = (*(long*)boxPtr) = mBlockFile.SwapLong( (*(long*)boxPtr) );		// Swap length long.	boxPtr += sizeof(long);		for( ; vCount > 0; vCount-- )	// Swap each entry:	{		mBlockFile.SwapStruct( boxPtr, inTemplate );		boxPtr += vSize;	}}/* --------------------------------------------------------------------------------	GetStructProperty:		Specialized variant of GetProperty() that knows about the data type it is		supposed to retrieve and does endian conversion. All parameters with the		same names as those of GetProperty() have the same meanings.		TAKES:		ioData		-	Pointer to a variable with the value to use when (over)writing.		inTemplate	-	A template describing the layout of the data structure.		GIVES:		ioData		-	The variable pointed to by this is set to the value retrieved						from the file, all properly endian-swapped.		REVISIONS: 		2000-11-11	MR		added VisualC support		2000-10-11	UK		Created.  ----------------------------------------------------------------------------- */void	XStackFile::GetStructProperty( XSFEntityRef entity, long propID,										void* ioData, const SftType inTemplate[],										bool create, bool overwrite ){	char*	boxPtr;	long	vSize;	void*	vDataCopy = NULL;		// Make copy of our data that we can swap:	vSize = mBlockFile.GetStructSize( inTemplate );	// FIX ME! Might speed up things to cache these.	vDataCopy = malloc(vSize);	if( vDataCopy == NULL )		throw MemoryError( __FILE__, "GetStructProperty", "couldn't allocate buffer for endian conversion." );	try {		memcpy( vDataCopy, ioData, vSize );		mBlockFile.SwapStruct( vDataCopy, inTemplate );		boxPtr = (char*)vDataCopy;			// Get property with user parameters: (Stupid VC++ needs cast to void**)		GetProperty( entity, propID, (void**) &boxPtr, &vSize, create, overwrite );	}	catch( exception& err )	{		free( vDataCopy );		throw;	}	free( vDataCopy );	// Copy out data again, swapping it if needed:	memcpy( ioData, boxPtr, vSize );	// FIX ME! Needs to error on larger returned than passed!	mBlockFile.SwapStruct( ioData, inTemplate );}