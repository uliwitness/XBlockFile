/*	***************************************************************************	PROJECT:	Joker		FILE:		XEndianFile.cpp		PURPOSE:	A block file for storing bits of information as				random-accessible blocks.			COPYRIGHT:	(C) Copyright 1999 by M. Uli Kusterer, all rights reserved.				Subject to the FreeCard GPL derivate, see				http://freecard.sourceforge.net for details.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness		REVISIONS:		1999-03-24	UK		Created.	************************************************************************ */#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */#include	"XEndianFile.h"#pragma mark [Globals]/* --------------------------------------------------------------------------------	Globals/Static Variables:   ----------------------------------------------------------------------------- */// Sizes of the type fields. Packed is actual size, The other is padded by appending zeroes.static long		sTypeSizes[]	= { 1, 2, 2, 2, 4, 4 };// On what boundary to align non-padded types:#if powerc	// Macintosh PowerPC:static long		sTypeBounds[]	= { 1, 2, 4 };	// 1 is ignore.#else		// Macintosh 680x0:static long		sTypeBounds[]	= { 2, 2, 2 };#endif// Globals defined by MSL that contain default creator for our files:#if MACINTOSH		// On Mac we need special magic to set type/creator codes.  #if defined(__MWERKS__)	// CodeWarrior does this using globals:    extern long			_ftype;    extern long			_fcreator;        // And Macro to access them in a non-cryptic way:	#define	DO_FILE_TYPE_MAGIC(ty,cr) 	{ _ftype = (long) ty; _fcreator = (long) cr; }  #else	// Other compilers might need different code. By default we just map to a no-op.    #define	DO_FILE_TYPE_MAGIC(ty,cr)	  #endif#else	// Non-Mac systems don't need this. We just map to a no-op.  #define	DO_FILE_TYPE_MAGIC(ty,cr)	#endif#pragma mark -#pragma mark [Init/Kill]/* --------------------------------------------------------------------------------	¥ CONSTRUCTOR:		Do some initialization.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */XEndianFile::XEndianFile(){	mFile = NULL;	mFileName[0] = 0;	// Make file name empty string.	mEndianSwapped = FALSE;		mCacheStart = 0;	mCacheLength = 0;	mCacheData = NULL;	  #if MACINTOSH	mFileType = 0;	mFileCreator = 0;  #endif}/* --------------------------------------------------------------------------------	¥ CONSTRUCTOR:		Create this file with a filename and open it.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */XEndianFile::XEndianFile( const char* inFileName ){	mFile = NULL;	mFileName[0] = 0;	// Make file name empty string.	strcpy( mFileName, inFileName );	mEndianSwapped = FALSE;		mCacheStart = 0;	mCacheLength = 0;	mCacheData = NULL;	  #if MACINTOSH	mFileType = 0;	mFileCreator = 0;  #endif}/* --------------------------------------------------------------------------------	¥ DESTRUCTOR:		Do some cleanup.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */XEndianFile::~XEndianFile(){	//Close(); // Doesn't work with inheritance...}#pragma mark [Class Methods]/* --------------------------------------------------------------------------------	Open:		Open this file. This creates the file if you als request write access		and there's no file of this name/type.			inAllowWrite	- boolean specifying whether you'd also like write permission.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::Open( bool inAllowWrite ){	if( mFile )		throw InternalError( __FILE__, "Open", "File is already open." );		// Make sure MSL creates file with our desired type and creator codes:	DO_FILE_TYPE_MAGIC(mFileType,mFileCreator);	// Macro.		// Try to actually open the file:	mFile = fopen( mFileName, inAllowWrite ? "r+b" : "rb" );	if( (mFile == NULL) && inAllowWrite )	// File doesn't exist yet, create it.		mFile = fopen( mFileName, "w+b" );	// Reset file creator & type to MSL default:	DO_FILE_TYPE_MAGIC(0,0);	// Macro.		// Report errors during	if( !mFile )		throw InternalError( __FILE__, "Open", "Couldn't open file." );}/* --------------------------------------------------------------------------------	Rename:		Rename this file.		TAKES:		inFileName -	New name for this file.		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::Rename( const char* inFileName ){	bool		vWasOpen = (mFile != NULL);		if( vWasOpen )	{		fclose( mFile );		mFile = NULL;	}		if( rename( mFileName, inFileName ) != 0 )		throw InternalError( __FILE__, "Rename", "Couldn't rename file." );	else		SetFileName( inFileName );		if( vWasOpen )	{		mFile = fopen( inFileName, "r+b" );		if( mFile == NULL )			throw InternalError( __FILE__, "Rename", "Couldn't reopen file." );	}}/* --------------------------------------------------------------------------------	Kill:		Delete this file.		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::Kill(){	Close();		remove( mFileName );}/* --------------------------------------------------------------------------------	Exists:		Determine whether this file exists.		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */bool	XEndianFile::Exists(){	bool		vExists;		if( mFile )		return TRUE;		mFile = fopen( mFileName, "rb" );	// Fails if file doesn't exist.	vExists = mFile != NULL;	if( vExists )	// We just opened the file, so ...		fclose( mFile );	// ... close it again!		return vExists;}/* --------------------------------------------------------------------------------	Close:		Close this file.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::Close(){	if( mFile )	{		int	vError = fclose( mFile );		mFile = NULL;	// File is probably invalid now.				if( vError != 0 )			throw InternalError( __FILE__, "Close", "Couldn't close file." );	}}/* --------------------------------------------------------------------------------	GetLength:		Return the size of this file in bytes.		TAKES:		-		GIVES:		size_t -	The size of this file in bytes.		REVISIONS:		1999-06-23	UK		Created.   ----------------------------------------------------------------------------- */size_t	XEndianFile::GetLength(){	size_t		vLength,				vOldMark;		vOldMark = ftell( mFile );	// Remember old mark.		// Go to end of file and determine mark position there to get file's size:	if( fseek( mFile, 0, SEEK_END ) != 0 )		throw InternalError( __FILE__, "GetLength", "Couldn't seek to end of file." );	vLength = ftell( mFile );		if( fseek( mFile, vOldMark, SEEK_SET ) != 0 )	// Restore old mark.		throw InternalError( __FILE__, "GetLength", "Couldn't restore previous mark position." );		return vLength;}/* --------------------------------------------------------------------------------	SetOffset:		Set this file's mark to the specified position (in bytes).		TAKES:		pOffs -	The offset to move to.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::SetOffset( size_t pOffs ){	if( fseek( mFile, pOffs, SEEK_SET ) != 0 )		throw InternalError( __FILE__, "SetOffset", "Couldn't seek into file." );}/* --------------------------------------------------------------------------------	MoveOffset:		Advance the file's read/write mark by the specified number of bytes.		Also takes negative distances.		TAKES:		pOffs -	The offset to move by.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::MoveOffset( size_t pOffs ){	if( fseek( mFile, pOffs, SEEK_CUR ) != 0 )		throw InternalError( __FILE__, "MoveOffset", "Couldn't seek into file." );}/* --------------------------------------------------------------------------------	GetOffset:		Return the current offset of this file's read/write mark.		TAKES:		-		GIVES:		size_t -	The offset in bytes.		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */size_t	XEndianFile::GetOffset(){	size_t		vOldMark;		vOldMark = ftell( mFile );		return vOldMark;}/* --------------------------------------------------------------------------------	Read:		Read the specified amount of data from the file into a pointer.		TAKES:		ioData -	A pointer of size inLength.		inLength -	The amount of data to read.		GIVES:		outData -	This pointer now contains the data read.		REVISIONS:		1999-12-20	UK		Added caching support.		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::Read( void* ioData, size_t inLength ){	if( fread( ioData, sizeof(char), inLength, mFile ) != inLength )		throw InternalError( __FILE__, "Read", "Couldn't read specified amount of data." );}/* --------------------------------------------------------------------------------	ReadLong:		Read a long from the file, performing endian conversion if needed.		TAKES:		-		GIVES:		long -	The data read (& converted).		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */long	XEndianFile::ReadLong(){	unsigned long		vNumber;		Read( &vNumber, sizeof(unsigned long) );		if( mEndianSwapped )	{		vNumber =	ENDIAN_SWAP32(vNumber);	}		return( (long) vNumber );}/* --------------------------------------------------------------------------------	WriteLong:		Write a long to the file, performing endian conversion if needed.		TAKES:		pNumber -	The number to write.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::WriteLong( long pNumber ){	unsigned long		vNumber = (unsigned long) pNumber;		if( mEndianSwapped )	{		vNumber =	ENDIAN_SWAP32(vNumber);	}		Write( &vNumber, sizeof(unsigned long) );}/* --------------------------------------------------------------------------------	ReadShort:		Read a short from the file, performing endian conversion if needed.		TAKES:		-		GIVES:		short -	The data read (& converted).		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */short	XEndianFile::ReadShort(){	unsigned short		vNumber;		Read( &vNumber, sizeof(unsigned short) );		if( mEndianSwapped )	{		vNumber =	ENDIAN_SWAP16(vNumber);	}		return( (short) vNumber );}/* --------------------------------------------------------------------------------	WriteShort:		Write a short to the file, performing endian conversion if needed.		TAKES:		pNumber -	The number to write.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::WriteShort( short pNumber ){	unsigned short		vNumber = (unsigned short) pNumber;		if( mEndianSwapped )	{		vNumber =	ENDIAN_SWAP16(vNumber);	}		Write( &vNumber, sizeof(unsigned short) );}/* --------------------------------------------------------------------------------	ReadChar:		Read a byte from the file. No conversion needed.		TAKES:		-		GIVES:		char -	The data read (& converted).		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */char	XEndianFile::ReadChar(){	unsigned char		vNumber;		Read( &vNumber, sizeof(unsigned char) );		return( (char) vNumber );}/* --------------------------------------------------------------------------------	WriteChar:		Write a char to the file. No conversion needed.		TAKES:		pNumber -	The number to write.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::WriteChar( char pNumber ){	unsigned char		vNumber = (unsigned char) pNumber;		Write( &vNumber, sizeof(unsigned char) );}/* --------------------------------------------------------------------------------	Write:		Write the specified amount of data from the specified pointer to the file.		TAKES:		inData -	A pointer containing the data to write.		inLength -	The amount of data to write.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::Write( void* inData, size_t inLength ){	if( fwrite( inData, sizeof(char), inLength, mFile ) != inLength )		throw InternalError( __FILE__, "Write", "Couldn't write specified amount of data." );}/* --------------------------------------------------------------------------------	WriteStruct:		Write the specified struct to the file as packed data.		TAKES:		inData -		A pointer containing the data to write.		inTemplate -	An array terminated by SFT_END containing a list of field						types of the structure.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::WriteStruct( void* inData, const SftType inTemplate[] ){	long		x = 0,				vPadding;	char*		dataPtr = (char*) inData;		while( inTemplate[x] != SFT_END )	{		vPadding = sTypeBounds[ inTemplate[x] /2 ];				// Align this:		if( vPadding != 1 )			dataPtr += ((long) dataPtr) % vPadding;				// Write field data to file:		switch( sTypeSizes[ inTemplate[x] & ~1 ] )	// Make number even, cause next lower even number is actual size of data type.		{			case 1:				WriteChar( (*dataPtr) );				break;						case 2:				WriteShort( (*(short*)dataPtr) );				break;						case 4:				WriteLong( (*(long*)dataPtr) );				break;		}				// Skip this field and any additional bytes at its end:		dataPtr += sTypeSizes[inTemplate[x]];	// Move past this field.				x++;	}}/* --------------------------------------------------------------------------------	ReadStruct:		Read the specified struct from the file.		TAKES:		inData -		A pointer containing the data to write.		inTemplate -	An array terminated by SFT_END containing a list of field						types of the structure.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */void	XEndianFile::ReadStruct( void* ioData, const SftType inTemplate[] ){	long		x = 0,				vPadding;	char*		dataPtr = (char*) ioData;		while( inTemplate[x] != SFT_END )	{		vPadding = sTypeBounds[ inTemplate[x] /2 ];				// Align this:		if( vPadding != 1 )			dataPtr += ((long) dataPtr) % vPadding;				// Write field data to file:		switch( sTypeSizes[ inTemplate[x] & ~1 ] )	// Make number even, cause next lower even number is actual (=packed) size of data type.		{			case 1:				(*dataPtr) = ReadChar();				break;						case 2:				(*(short*)dataPtr) = ReadShort();				break;						case 4:				(*(long*)dataPtr) = ReadLong();				break;		}				// Skip this field and any additional bytes at its end:		dataPtr += sTypeSizes[inTemplate[x]];	// Move past this field.				x++;	}}/* --------------------------------------------------------------------------------	SwapStruct:		Endian-swap the specified struct's data if we need to endian-convert.		TAKES:		inData -		A pointer containing the data to write.		inTemplate -	An array terminated by SFT_END containing a list of field						types of the structure.		GIVES:		-		REVISIONS:		2000-10-11	UK		Created based on ReadStruct.   ----------------------------------------------------------------------------- */void	XEndianFile::SwapStruct( void* ioData, const SftType inTemplate[] ){	if( !mEndianSwapped )	// Do nothing if no conversion needed.		return;		long		x = 0,				vPadding;	char*		dataPtr = (char*) ioData;		while( inTemplate[x] != SFT_END )	{		vPadding = sTypeBounds[ inTemplate[x] /2 ];				// Align this:		if( vPadding != 1 )			dataPtr += ((long) dataPtr) % vPadding;				// Write field data to file:		switch( sTypeSizes[ inTemplate[x] & ~1 ] )	// Make number even, cause next lower even number is actual (=packed) size of data type.		{			case 1:				// Do nothing, we needn't swap chars.				break;						case 2:				(*(short*)dataPtr) = ENDIAN_SWAP16((*(short*)dataPtr));				break;						case 4:				(*(long*)dataPtr) = ENDIAN_SWAP32((*(long*)dataPtr));				break;		}				// Skip this field and any additional bytes at its end:		dataPtr += sTypeSizes[inTemplate[x]];	// Move past this field.				x++;	}}/* --------------------------------------------------------------------------------	GetStructSize:		Calculate the size of the struct whose template is passed on disk.		TAKES:		inTemplate -	An array terminated by SFT_END containing a list of field						types of the structure.		GIVES:		-		REVISIONS:		1999-07-19	UK		Created.   ----------------------------------------------------------------------------- */size_t	XEndianFile::GetStructSize( const SftType inTemplate[] ){	long		x = 0;	size_t		sSize = 0;		while( inTemplate[x] != SFT_END )	{		sSize += sTypeSizes[ inTemplate[x] & ~1 ];	// Make number even, cause next lower even number is actual (=packed) size of data type.				x++;	}		return sSize;}/* --------------------------------------------------------------------------------	CopyBetweenFiles:		Copy data from one file to the other, or inside one file, in chunks of 64k		(or whatever DATA_COPY_CHUNK_SIZE is set to), thus allowing to move blocks		of data that are too large to fit in RAM.				The buffer for copying is currently allocated on the stack. If you don't		like this add a mCopyChunkSize member to this class and replace the		constant DATA_COPY_CHUNK_SIZE through it in this function. You'll also		need to allocate the buffer using malloc(). Init mCopyChunkSize to		DATA_COPY_CHUNK_SIZE in the constructor. You could also add some fuzzy		logic that decreases the copy buffer size if RAM is too low to allocate		a full block.		TAKES:		srcFile -	The file to copy from.		dstFile -	The file to copy to. May point to the same FILE* as srcFile.		srcOffs -	The mark position from which to begin reading the data to					copy.		dstOffs -	The mark position from which to begin writing the data.		length -	The amount of data to copy.		GIVES:		-		REVISIONS:		1999-07-19	UK		Moved here from XBlockFile.		1999-06-23	UK		Made this work when srcFile and dstFile are the same.		1999-06-19	UK		Extracted from Compact().   ----------------------------------------------------------------------------- */void	XEndianFile::CopyBetweenFiles( FILE* srcFile, FILE* dstFile, size_t srcOffs,										size_t dstOffs, size_t length ){	size_t		vLength = length,				vSrcOffs = srcOffs,				vDstOffs = dstOffs;	char		vCopyBuffer[DATA_COPY_CHUNK_SIZE];		// Now we copy over the data in handy chunks:	while( vLength != 0 )	{		// How much do we copy this time? If less than 16k is left we only copy what's left, of course:		size_t		vAmountToCopy = (vLength < DATA_COPY_CHUNK_SIZE) ? vLength : DATA_COPY_CHUNK_SIZE;				if( fseek( srcFile, vSrcOffs, SEEK_SET ) != 0 )	// Set place where we start reading.			throw InternalError( __FILE__, "CopyBetweenFiles", "Couldn't seek into source file." );				// Read from source file:		if( fread( vCopyBuffer, sizeof(char), vAmountToCopy, srcFile ) != vAmountToCopy )			throw InternalError( __FILE__, "CopyBetweenFiles", "Couldn't read from source file." );				vSrcOffs += vAmountToCopy;				if( fseek( dstFile, vDstOffs, SEEK_SET ) != 0 )	// Set place where we start writing.			throw InternalError( __FILE__, "CopyBetweenFiles", "Couldn't seek into dest file." );				// Write to block file:		if( fwrite( vCopyBuffer, sizeof(char), vAmountToCopy, dstFile ) != vAmountToCopy )			throw InternalError( __FILE__, "CopyBetweenFiles", "Couldn't write to dest file." );				vDstOffs += vAmountToCopy;				// Only differs if it was smaller:		if( vAmountToCopy != DATA_COPY_CHUNK_SIZE )			vLength = 0;		else			vLength -= DATA_COPY_CHUNK_SIZE;	}}