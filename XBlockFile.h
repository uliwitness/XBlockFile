/*	***************************************************************************	PROJECT:	Joker		FILE:		XBlockFile.h		PURPOSE:	A block file for storing bits of information as random-accessible blocks.			COPYRIGHT:	(C) Copyright 1999-2000 by M. Uli Kusterer, all rights reserved.				Subject to the FreeCard GPL derivate, see				http://freecard.sourceforge.net for details.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness			REVISIONS:		1999-03-24	UK		Created.					************************************************************************ */// Make sure this is included only once:#ifndef X_BLOCK_FILE_H#define X_BLOCK_FILE_H#pragma mark [Headers]/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Headers:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */   #include	"JokerUtilities.h"#include	"XEndianFile.h"#include	"XBusyProc.h"#include	<map>#pragma mark [Data Structures]/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Data Structures:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */class	XBlockFile;	// Forward.// ID of a block, a positive number:typedef	unsigned long	XBlockID;// Offset in file:typedef unsigned long	XBlockOffset;// Flags data type:typedef unsigned long	XBlockFlags;/* To work around recursive definitions, we define a void pointer in XBlockEntry	into which we'll put an XBlockMap object which we create and delete in the	con-/destructor.  */// Each entry in the file's map is of this type:class XBlockEntry{public:	XBlockID						mId;			// Index of block in map.	XBlockOffset					mOffset;		// Start of block data in file.	XBlockOffset					mLength;		// Physical size of block data in file.	XBlockOffset					mLogLength;		// Used size of block data in file, including sub block map.	XBlockOffset					mSubMapLength;	// <Obsolete>	void*							mPointer;		// Pointer to loaded block data (malloc! NOT new!).	XBlockOffset					mPointerLength;	// Length of data in RAM.	XBlockFlags						mFlags;			// Some flags for this entry.	void*							mSubBlocks;		// List of sub-blocks of this block. This holds an XBlockMap*.	XBlockFile*						mFile;			// The file this block belongs to.	XBlockEntry*					mSuperEntry;	// The entry this is a sub-entry of. NULL if root entry.	// If you add a data member, be sure to fix XBlockFile::DumpMap() to output that, too!		XBlockEntry( XBlockFile* inFile = NULL, XBlockEntry* superEntry = NULL );	XBlockEntry( XBlockEntry& inEntry );	// Copy constructor.	~XBlockEntry();		void			SwapData( XBlockEntry& ioBlock );	void			UnloadData()	{ if( mPointer ) { free( mPointer ); mPointer = NULL; mPointerLength = 0; }; };		XBlockEntry&	operator=(XBlockEntry& inEntry);		XBlockEntry*	GetBlockEntry( XBlockID inID );		// Get a sub block of this one.	XBlockFile*		GetOwningFile()						{ return mFile; };		size_t			GetLength();		void			WriteToFile( XEndianFile& destFile );protected:	void	ModelMeAfter( XBlockEntry& inEntry );};// Size of block entry in RAM:#define BLOCK_ENTRY_SIZE		(sizeof(XBlockID) +(sizeof(XBlockOffset) *4) +sizeof(XBlockFlags) +(sizeof(void*) *2))// Size of block entry on disk:#define	DISK_BLOCK_ENTRY_SIZE	(sizeof(XBlockID) +(sizeof(XBlockOffset) *3) +sizeof(XBlockFlags) +sizeof(XBlockOffset))class XBlockWastedSpace{public:	XBlockOffset	mOffset;	XBlockOffset	mLength;};// Size of fields in above class so XEndianFile can convert it:static SftType	XBFWastedSpaceTmpl[] = { SFT_LONG, SFT_LONG, SFT_END };// Size of wasted entry on disk:#define DISK_WASTE_ENTRY_SIZE	(sizeof(XBlockOffset) *2)// Some convenient names to use instead of these huge C++ ones:typedef multimap<XBlockOffset,XBlockWastedSpace>	XWastedBlockList;typedef XWastedBlockList::iterator					XWastedIterator;typedef XWastedBlockList::value_type				XWastedListItem;typedef map<XBlockID,XBlockEntry>					XBlockMap;typedef	XBlockMap::iterator							XBlockMapIterator;#pragma mark [Constants]/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Constants:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */enum{	// File version that indicates format:	BLOCK_FILE_VERSION					= 0,	// This is stored big-endian *always*!		// Size of data before block data begins:	BLOCK_FILE_HEADER_FILEEND_OFFSET	= (sizeof(unsigned short) +sizeof(unsigned long)),	// This is where mFileEnd is saved.	BLOCK_FILE_HEADER_MAPOFFS_OFFSET	= (BLOCK_FILE_HEADER_FILEEND_OFFSET +sizeof(unsigned long)),	// Here mMapOffset is saved.	BLOCK_FILE_HEADER_SIZE				= (BLOCK_FILE_HEADER_MAPOFFS_OFFSET +sizeof(XBlockOffset)),		// Here block data starts.		// Amount of bytes to add to physical size of a block when we run out of space during streaming:	AUTO_FLUFF_AMOUNT					= 100};/* Constants used to assign file types on Mac. Other platforms probably don't	need this as they append that information to file names, but always	remember to call XEndianFile's SetFileType() method with the appropriate	constants for all non-temporary files. */enum{#if MACINTOSH	BLOCK_FILE_TYPE		= 'BLOK',	// Type of block file.	BLOCK_FILE_CREATOR	= 'FREE'	// Creator code of Joker.#else	BLOCK_FILE_TYPE		= 1,		// In case we later need to distinguish file types, use a different number here.	BLOCK_FILE_CREATOR	= 0			// Zero means Joker itself.#endif};// File header flags:enum{	FILE_FLAG_NATIVE_ENDIAN		= (1 << 0),	// Numbers etc. were written Mac-endian.	FILE_FLAG_FOREIGN_ENDIAN	= (1 << 7)	// This is FILE_FLAG_NATIVE_ENDIAN converted to the other endian mode.};// Block flags:enum{	// Block data in RAM differs from on-disk version (cleared when saved to disk).	BLOCK_DIRTY					= (1 << 0),	// Block data hasn't been saved to disk yet. (cleared when saved to disk) WARNING: Offset & length are invalid!	BLOCK_RAM_ONLY				= (1 << 1),	// Block may be unloaded from RAM when it is saved or more memory is needed and it isn't dirty.	BLOCK_PURGEABLE				= (1 << 2),	/* This block contains a map of its sub-blocks. Any data storage/retrieval is		re-routed to sub-block 0. The map may be loaded into mSubBlocks. */	BLOCK_HAS_SUB				= (1 << 3),	/* All flags that are not supposed to be saved to disk must be added to		this mask. The inverse of this will be used to mask out these flags		during saving and compacting. */	VOLATILE_BLOCK_FLAGS_MASK	= (BLOCK_DIRTY | BLOCK_RAM_ONLY)};#pragma mark [Class Declaration]/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Class declaration:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */class	XBlockFile : public XEndianFile{friend class XBlockEntry;protected:	bool				mFileChanged;	// TRUE if map needs to be written again. If XBlockFile changes anything, it sets this!!!	XBlockMap			mBlockMap;		// Our map of blocks containing actual data.	XWastedBlockList	mWastedBlocks;	// List of blocks ready for re-use.	XBlockOffset		mMapOffset;		// Offset of map in file.	XBlockOffset		mMapLength;		// Length of map in file.	XBusyProcPtr		mBusyProc;		// Procedure to call when this is busy to provide feedback.	XBlockOffset		mFileEnd;		// The place where we'll append new blocks to our file.	public:	XBlockFile();	XBlockFile( char* fName );			// Also opens the file.	// Preparation/cleanup:	virtual void	Open( bool allowWrite );	virtual void	Close();	virtual void	Compact();	virtual void	SaveFile();	virtual void	WriteEmptyBlockFile();	// Specify file this object points to:	virtual void	SetFileName( char* inFileName )			{ strcpy( mFileName, inFileName ); };	virtual void	GetFileName( char* outFileName )		{ strcpy( outFileName, mFileName ); };	// Manipulating root-level blocks (shortcut methods):	virtual void*	GetBlock( XBlockID inID );	virtual void	SetBlock( XBlockID inID, void* inData, XBlockOffset inLength );	virtual void	GetBlockToFile( XBlockID inID, FILE* inFile );	virtual void	SetBlockFromFile( XBlockID inID, FILE* inFile );	virtual void	KillBlock( XBlockID inID );// streaming:	virtual void	StreamToBlockEntry( XBlockEntry *vTheBlock,										void* inData, XBlockOffset inLength,										XBlockOffset inWritePosition );	virtual void	StreamToBlock( XBlockID inID,									void* inData, XBlockOffset inLength,									XBlockOffset inWritePosition );	virtual void	StreamFromBlockEntry( XBlockEntry* vTheBlock,											void* ioData, XBlockOffset inLength,											XBlockOffset inWritePosition );	virtual void	StreamFromBlock( XBlockID inID,										void* ioData, XBlockOffset inLength,										XBlockOffset inWritePosition );	virtual void	FluffBlock( XBlockEntry* inBlock, size_t inAmount );	// Feedback:	void			SetBusyProc( XBusyProcPtr n )	{ mBusyProc = n; };		void			DumpMap()	{ DumpMap( mBlockMap ); DumpWastedList(); };	void			DumpWastedList();	void 			DumpMap( XBlockMap &inMap, unsigned long inNestLevel = 0 );	// Debugging only!	// Working with blocks:	virtual XBlockEntry*	AddSubBlock( XBlockEntry* inEntry, XBlockID inID,											void* inData, XBlockOffset inLength );	virtual void			ResizeBlockEntry( XBlockEntry* vTheEntry, XBlockOffset inLength );	virtual XBlockEntry*	GetBlockEntry( XBlockID inID );	// Gets entry for root block.	virtual void*			GetBlockData( XBlockEntry* vFoundEntry );	// Pointer is owned by XBF!	XBlockEntry*			GetSubBlockEntry( XBlockEntry* owner, XBlockID inID )	{ return( owner->GetBlockEntry( inID ) ); };	protected:	virtual XBlockEntry*	AddBlockToMap( XBlockMap& inMap, XBlockID inID, void* inData,											XBlockOffset inLength );	virtual	XBlockMap*		GetSubBlockMap( XBlockEntry* inEntry );		virtual void			LoadBlockMap();	virtual void			LoadWastedIntoList();	virtual void			LoadBlocksIntoList( XBlockMap& ioList, XBlockEntry* forEntry = NULL );	virtual void			KillFileMap();	virtual XBlockOffset	WriteBlockMap( XBlockMap& vTheMap, XBlockOffset vBlockOffs, XBlockOffset &vFileEnd );	virtual XBlockOffset	StoreOneMapWithoutData( XBlockMap& theMap, XBlockOffset vWritePos,													XEndianFile& destFile );	virtual void			CompactBlockMap( XBlockMap &srcMap, size_t &vCurrWritePosition,										XEndianFile& tempFile, XBlockMap& dstMap );		virtual void			WasteBlockEntry( XBlockEntry* inEntry )		{ WasteBlockEntry( inEntry, mBlockMap ); };	virtual void			WasteBlockEntry( XBlockEntry* inEntry, XBlockMap& inMap );	virtual XBlockEntry*	SplitBlock( XBlockEntry* inEntry, XBlockOffset inDesiredSize );	virtual void			KillMapEntry( XBlockEntry* inEntry )	{ KillMapEntry( inEntry, mBlockMap ); };	virtual void			KillMapEntry( XBlockEntry* inEntry, XBlockMap& inMap );	virtual XBlockEntry*	MoveBlockToEnd( XBlockEntry* inBlock );		virtual bool			GetWastedBlockEntry( XBlockOffset inDesiredSize,												XBlockWastedSpace* outBlockSpace );		virtual XBlockOffset	CalculateFileEnd();};#endif /* X_BLOCK_FILE_H */