/* ================================================================================	PROJECT:	XStackFile		FILE:		XStackFile.h		PURPOSE:	Stack file class			COPYRIGHT:	(C) Copyright 2000 by M. Uli Kusterer, all rights reserved.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness			REVISIONS:		2000-07-07	UK		Created.				   ============================================================================= */#ifndef XSTACKFILE_H#define XSTACKFILE_H#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */   #include	"XBlockFile.h"#pragma mark [Constants]/* --------------------------------------------------------------------------------	Constants:   ----------------------------------------------------------------------------- *//*	The following constants are the block IDs used to store the data of a stack	in a block file. There are some shared by certain objects (which start at	some multiple of 1000), while others are unique to one object type (and	start at 1). <anything>List blocks are container blocks that usually	contain other sub-blocks. Most of the block IDs are abstracted away by	this class.*/// First level block IDs (immediately in file):enum{	FILE_INFO_BLOCK_ID	= 1,	// Block with some info on file (maybe password, author info ...)	STACK_LIST_BLOCK_ID,		// Block containing the stacks in this file.	RESOURCE_LIST_BLOCK_ID		// Block containing this file's data fork resources (icons, sounds ...)};// Resource block IDs:enum{	IMAGE_LIST_BLOCK_ID	= 500,	// Block with all images (icons,card pictures...) in it.	SOUND_LIST_BLOCK_ID,		// Block with all sounds in it.	REPORT_LIST_BLOCK_ID		// Block with all report templates in it.};// Resource block types:	(Client uses this to access blocks, not the block IDs!)enum{	STAR_TYPE_IMAGE		=	IMAGE_LIST_BLOCK_ID,	STAR_TYPE_SOUND		=	SOUND_LIST_BLOCK_ID,	STAR_TYPE_REPORT	=	REPORT_LIST_BLOCK_ID};typedef XBlockID	XSFStarType;// Object block IDs (same for all message hierarchy object sub blocks, aka "entity" sub blocks):enum{	SCRIPT_BLOCK_ID				= 1000,		// Block that contains all info for this object's script.	PROPERTY_LIST_BLOCK_ID,					// Block that contains built-in properties.	USER_PROPERTY_LIST_BLOCK_ID				// Block that contains user properties.};// Script block sub-block IDs (for Anthony's Interpreter):enum{	SCRIPT_TEXT_BLOCK_ID	= 400,	// Plain-text script as entered by the user.	COMPILED_SCRIPT_BLOCK_ID,		// Script compiled into our kind of bytecode.	META_DATA_BLOCK_ID,	VARIABLE_TABLE_BLOCK_ID,		// The script's variable lists ... ?	LINE_MAPPING_TABLE_BLOCK_ID,	// Info so debugger knows which compiled instruction corresponds to which line.	TRANSLATED_SCRIPT_BLOCK_ID		// I guess this is tokenized form ... ?};// Property list block sub-block IDs:enum{	FIXED_SIZE_PROP_TABLE_BLOCK_ID = 300,	// Table with offsets into fixed size property table for each property.	FIXED_SIZE_PROPERTIES_BLOCK_ID,			// Fixed size properties (loc, rect) go here.	// Properties that need their own blocks have IDs >= 1000	PART_CONTENTS_BLOCK_ID = 2000,			// Button and field contents.	PART_STYLES_BLOCK_ID					// Text style info for field contents.};// Stack block sub-block IDs (see 'Object block IDs' for the others):enum{	STACK_BKGND_LIST_BLOCK_ID	= 200,	// Block containing all backgrounds in this stack.	STACK_CARD_LIST_BLOCK_ID			// Block containing all cards in this stack.};// Layer block sub-block IDs (same for all bkgnds and cards):enum{	LAYER_PART_LIST_BLOCK_ID	= 7000,	// Block listing all buttons and fields on this layer.	LAYER_IMAGE_BLOCK_ID,				// Block with card picture in it.	LAYER_IMAGE_MASK_BLOCK_ID			// Block with card picture's mask in it.};// Card block sub-block IDs:enum{	CARD_UNSHARED_PART_DATA_BLOCK_ID	= 99	// Block with a part & property lists to override bg part's properties (e.g. hilite, text) if the part doesn't have sharedText or sharedHilite set.};// Bkgnd block sub-block IDs:enum{	BKGND_MEMBER_CARDS_BLOCK_ID			= 99	// Block with the IDs of the cards belonging to this bg.};// Part kinds: These constants are used to create the proper object for a part:enum{	PART_KIND_BUTTON = 0,		// It is a button.	PART_KIND_FIELD,			// It is a text entry field.	PART_KIND_GRAPHIC,			// It is a draw graphic object.	PART_KIND_MOVIE,			// It is a movie player.	PART_KIND_GROUP				// It is an group containing objects.};// Field styles:enum{	FLD_STYLE_TRANSPARENT = 0,	// See-through.	FLD_STYLE_OPAQUE,			// Erase background but don't frame.	FLD_STYLE_RECTANGLE,		// Frame & erase background.	FLD_STYLE_SHADOW,			// Like rectangle plus drop shadow.	FLD_STYLE_SCROLLING			// Like rectangle but with scrollbar.};// Button styles:enum{	BTN_STYLE_TRANSPARENT = 0,	// See-through.	BTN_STYLE_OPAQUE,			// Erase background but don't frame.	BTN_STYLE_RECTANGLE,		// Frame & erase background.	BTN_STYLE_SHADOW,			// Like rectangle plus drop shadow.	BTN_STYLE_POPUP,			// Popup menu.	BTN_STYLE_STANDARD,			// Standard button with OS-native looks.	BTN_STYLE_DEFAULT,			// Like standard but with border indicating it's triggered when return is pressed. Note that this button is inset by 3 pixels.	BTN_STYLE_ROUNDRECT,		// Like shadow but with rounded corners.	BTN_STYLE_OVAL,				// Like transparent but mouse tracking and highlighting occurs inside an oval shape.	BTN_STYLE_NIFTY				// An image button for testing purposes.};/*	Property IDs are indexes into the fixed-size property offset table array.	The second bunch of IDs are property IDs for dynamic-size properties.	Dynamic-size properties' IDs all start at 65536 so you can pass them	to the same API as fixed-size properties and the API has a way to	distinguish them.*/#define	DYN_PROP_START_ID		65536/* Fixed size properties are all stored in one block. Since the stack file	doesn't know what size the data for a property is until you assign it	a value but it might need to create an entry for this property since	a property with a higher number has been assigned a value, the constant	FIXED_ENTRY_UNUSED is assigned to the offset field of any property that	doesn't have a value yet. This limits the complete size of all fixed	size properties to LONG_MAX (signed long). */#define FIXED_ENTRY_UNUSED		-1// Stack Property IDs: (fixed size)enum{	PROP_ID_STACK_RECT = 0		// "rect"};enum	// (variable size){	PROP_ID_STACK_SHORT_NAME = DYN_PROP_START_ID	// "short name"};// Card Property IDs: (fixed size)enum{	PROP_ID_CARD_DONT_SEARCH = 0,		// "dontSearch"	PROP_ID_CARD_NUMBER					// "number" -- used to determine order of cards.};enum	// (variable size){	PROP_ID_CARD_SHORT_NAME = DYN_PROP_START_ID	// "short name"};// Part Property IDs: (shared by fields, buttons etc.)enum{	PROP_ID_PART_RECT	=	5000,						// "rect"	PROP_ID_PART_VISIBLE,								// "visible"	PROP_ID_PART_PARTNUMBER,							// "partNumber" - Used to determine global layering on a card.	PROP_ID_PART_KIND,									// Button, field, grc, movie or whatever...	PROP_ID_PART_SHORT_NAME = DYN_PROP_START_ID +5000	// "short name"};// Button Property IDs: (fixed size)enum{	PROP_ID_BTN_RECT = PROP_ID_PART_RECT,				// "rect"	PROP_ID_BTN_VISIBLE = PROP_ID_PART_VISIBLE,			// "visible"	PROP_ID_BTN_PARTNUMBER = PROP_ID_PART_PARTNUMBER,	// "partNumber"	PROP_ID_BTN_KIND = PROP_ID_PART_KIND,				// Must be PART_KIND_BUTTON!	PROP_ID_BTN_HILITE = 600,							// "hilite"/"highlight"	PROP_ID_BTN_SHAREDHILITE,							// "sharedHilite"	PROP_ID_BTN_STYLE									// "style"};enum	// (variable size){	PROP_ID_BTN_SHORT_NAME = PROP_ID_PART_SHORT_NAME	// "short name"};// Field Property IDs: (fixed size)enum{	PROP_ID_FLD_RECT = PROP_ID_PART_RECT,				// "rect"	PROP_ID_FLD_VISIBLE = PROP_ID_PART_VISIBLE,			// "visible"	PROP_ID_FLD_PARTNUMBER = PROP_ID_PART_PARTNUMBER,	// "partNumber"	PROP_ID_FLD_KIND = PROP_ID_PART_KIND,				// Must be PART_KIND_FIELD!	PROP_ID_FLD_SELECTEDLINE = 700,						// "selectedLine"	PROP_ID_FLD_SHAREDTEXT,								// "sharedText"	PROP_ID_FLD_STYLE									// "style"};enum	// (variable size){	PROP_ID_FLD_SHORT_NAME = PROP_ID_PART_SHORT_NAME	// "short name"};#pragma mark [Data Types]/* --------------------------------------------------------------------------------	Data types:   ----------------------------------------------------------------------------- */typedef	XBlockEntry*		XSFEntityRef;	// Reference to any message hierarchy object (card,bg,stack,part).typedef	XSFEntityRef		XSFStackRef;	// Reference to a stack.typedef	XSFEntityRef		XSFBkgndRef;	// Reference to a background.typedef	XSFEntityRef		XSFCardRef;		// Reference to a card.typedef	XSFEntityRef		XSFPartRef;		// Reference to a part (field, button).typedef	XSFEntityRef		XSFLayerRef;	// Reference to a card or background.typedef XBlockEntry*		XSFStarRef;		// Reference to any data fork resource.typedef XBlockEntry*		XSFBlockRef;	// Reference to any other block (file info etc.) in this file.#pragma mark [Class Declaration]/* --------------------------------------------------------------------------------	Class declaration:   ----------------------------------------------------------------------------- */class	XStackFile{protected:	XBlockFile		mBlockFile;		// The actual file to which this is the interface.public:			XStackFile() : mBlockFile() {};			XStackFile( const char* fName ) : mBlockFile(fName) {};	virtual	~XStackFile()	{};		// Manage the file itself:	void	Open( bool allowWrite )		{ mBlockFile.Open(allowWrite); };	void	Close()						{ mBlockFile.Close(); };	void	Compact()					{ mBlockFile.Compact(); };		// Manipulate file's search path:	void	GetFileName( char* outFileName )		{ mBlockFile.GetFileName( outFileName ); };	void	SetFileName( const char* inFileName )	{ mBlockFile.SetFileName( inFileName ); };	void	Rename( const char* inFileName )		{ mBlockFile.Rename( inFileName ); };		// Manage data fork resources (aka 'Stars'):	XSFStarRef		GetStarByID( XSFStarType theType, XBlockID theID, bool create );	XSFStarRef		GetStarByNum( XSFStarType theType, unsigned long num );	void			GetStarData( XSFStarRef theStar, void* *theData, size_t *size );	void			SetStarData( XSFStarRef theStar, void* theData, size_t size );	unsigned long	CountStars( XSFStarType theType );		// Manage root blocks:	XSFBlockRef		GetBlockByID( XBlockID theID, void* vData, size_t inSize, bool create );	/*void			GetEntityBlockByID( XSFEntityRef entity, XBlockID theID, void* *ioData,										size_t *inSize, bool create = false,										bool overwrite = false );*/	XSFBlockRef		GetEntityBlockByID( XSFEntityRef entity, XBlockID theID,										void* inData, size_t inSize, bool create = false );	unsigned long	CountEntityBlocks( XSFEntityRef entity );	void			GetEntityBlockByNum( XSFEntityRef entity, unsigned long num, void* *ioData,										size_t *inSize, bool overwrite = false );	void			GetBlockData( XSFBlockRef theBlock, void* *theData, size_t *size );	void			SetBlockData( XSFBlockRef theBlock, void* theData, size_t size );	void			GetStructBlockData( XBlockID blockID, void* ioData, const SftType inTemplate[],										bool create, bool overwrite );		// Manage entities:	XSFStackRef		GetStackByID( XBlockID theID, bool create = false );	XSFCardRef		GetCardByID( XSFStackRef stack, XBlockID theID, bool create = false );	XSFBkgndRef		GetBkgndByID( XSFStackRef stack, XBlockID theID, bool create = false );	XSFPartRef		GetPartByID( XSFLayerRef cardOrBg, XBlockID theID, bool create = false );		XSFStackRef		GetStackByNum( unsigned long theNum );	XSFCardRef		GetCardByNum( XSFStackRef stack, unsigned long theNum );	XSFBkgndRef		GetBkgndByNum( XSFStackRef stack, unsigned long theNum );	XSFPartRef		GetPartByNum( XSFLayerRef cardOrBg, unsigned long theNum );		void			KillEntity( XSFEntityRef entity )	{ mBlockFile.KillBlockEntry( entity ); };	XBlockID		GetEntityID( XSFEntityRef entity )	{ return entity->mId; };		unsigned long	CountStacks();	unsigned long	CountStackCards( XSFStackRef stack );	unsigned long	CountStackBkgnds( XSFStackRef stack );	unsigned long	CountLayerParts( XSFLayerRef cardOrBg );		void*			GetEntityRefCon( XSFEntityRef entity );	void			SetEntityRefCon( XSFEntityRef entity, void* rc );		// Entity properties:	void			GetShortProperty( XSFEntityRef entity, long propID, short* box,									bool create = false, bool overwrite = false );	void			GetLongProperty( XSFEntityRef entity, long propID, long* box,										bool create = false, bool overwrite = false );	void			GetStructProperty( XSFEntityRef entity, long propID,										void* ioData, const SftType inTemplate[],										bool create = false, bool overwrite = false );	void			GetStructListProperty( XSFEntityRef entity, long propID,										void* ioData, const SftType inTemplate[],										bool create = false, bool overwrite = false );	void			GetProperty( XSFEntityRef entity, long propID, void* *ioData, long *ioSize,									bool create = false, bool overwrite = false );	void			GetUserProperty( XSFEntityRef entity, char* propName, void* *ioData, XBlockOffset *ioSize,									bool create = false, bool overwrite = false, XBlockOffset idx = 0 );		// Miscellaneous:	void			SetBusyProc( XBusyProcPtr n )	{ mBlockFile.SetBusyProc(n); };};#pragma mark [Exceptions]/* --------------------------------------------------------------------------------	Exceptions:   ----------------------------------------------------------------------------- */class XSFBlockNotFoundError : public InternalError{public:	XSFBlockNotFoundError( const string& fle, const string& fcn, const string& msg )		: InternalError( fle, fcn, msg ) {};};#endif /*XSTACKFILE_H*/