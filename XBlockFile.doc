/*	***************************************************************************	PROJECT:	Joker		FILE:		XBlockFile.doc		PURPOSE:	Documentation on XBlockFile.			COPYRIGHT:	(C) Copyright 1999 by M. Uli Kusterer, all rights reserved.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness		REVISIONS:		2000-10-11	UK		Reflected size reduction of map entries.		2000-05-14	UK		Updated and re-integrated format.htm into this.		1999-07-18	UK		Created.					************************************************************************ */#if 0This is the programmers' documentation of the file format used by theXBlockFile class that implements a file consisting of an arbitrary number ofchunks of data (called "blocks") that are indexed using an ID. Each block mayhave an arbitrary number of sub-blocks, which in turn may have an arbitrarynumber of sub-blocks and so on.XBlockFile transparently handles management of blocks, including support forstreaming from/to blocks, changing block sizes or performing endian conversion.Furthermore, XBlockFile allows compacting a block file to have it take up aslittle disk space as possible by stripping no longer used blocks from a file.Note that this does not include compression.The requirements for an XBlockFile implementation are:- Stability and data-safety: Ideally, no action performed on an XBlockFileshould result in the file becoming invalid under any condition, includingerrors like a full disk.Ê- Speed: XBlockFile is guaranteed to perform well even with huge numbers ofblocks and file sizes of several megabytes.Ê- Low RAM footprint: XBlockFile will work with little memory. In particular,no implementation may require the whole file to be loaded into RAM, and itmust support streaming of huge blocks without loading that block into RAM.Ê- Limitless storage: Ideally, any XBlockFile implementation should be limitedonly by available RAM and disk space when it comes to creating large blocksand block files. There is no such thing as a maximum number of blocks.Ê- Platform safety. Any XBlockFile implementation must be written in a way thatit can read/write binary exchangeable files written on any platform, nomatter whether big or little endian, RISC or CISC CPU etc. As a compromiseto allow for more speed, it may generate files that contain a flag specifyingthe endian-mode, but it must be able to transparently convert files withdifferent endian-modes than the native mode of the current platform.Compacting must result in native-endian files, though.ACTUAL FILE FORMAT:	2 bytes		File version (zero)	1 byte 		File flags	4 bytes		Offset to end of file (=size of file)	4 bytes		Offset into file to map start				... <block data> ...	Block map:	4 bytes		Number of map entries		Array of Block Map entries:		4 bytes		Unique block ID		4 bytes		Offset to start of block data		4 bytes		Length of block data in bytes		1 byte 		Block flags	4 bytes		Number of wasted blocks		Array of Wasted Space entries:		4 bytes		Offset to start of wasted data		4 bytes		Length of wasted data in bytes				... <block data> ...Every block may contain either block data, or it may be a container of otherblocks. In this case, its data consists of a block map that has the same formatas the file's block map except that it doesn't contain a list of wasted blocks(as wasted blocks are all kept track of in the file's wasted list). Whether ablock contains data or a map is indicated by a block flag. The block onlycontains the block map entries, it doesn't contain the actual data of its subblocks. These are stored at any arbitrary location in the file just like thedata of root-level blocks; that is, data of blocks and sub-blocks(and sub-sub-blocks etc.) are stored intermixed in a file.Length of wasted data is the physical block length, the logical length is notimportant as all data is wasted, not just the logical data.An XBlockFile consists of a header, a map, and the actual block data.The header contains the offset to the map, a file version to allow for futurechanges while maintaining some degree of backward compatibility, and 1 byte (8bits) of flags.The map consists of an unsigned long specifying the number of blocks in the file,and that many block entries. Each block entry in turn holds 4 bytes of flags foreach block as well as its ID, the offset of its data in the file and thelogical and physical length of the block's data (logical length means how much ofthe block is currently in use).To achieve greater security and to prevent frequent file corruption the old map isnot overwritten but rather marked as a wasted block which can be re-used for themap or another block later. The map offset at the start of the file is not changeduntil the new map has been written. This has the advantage that if anything shouldgo wrong during saving, the old map is still present and the file is still valid.Each block has a logical and a physical size, where the logical size is always lessthan or the same as the physical size. This is useful when streaming, as each timethe physical size is increased, the possibility of a large block being moved to theend of the file to make room for the new block exists, causing much slow disk access.By increasing the physical size in steps of e.g. 100 bytes and then having the logicalsize catch up before increasing the physical size again, streaming can be done withincreased speed, and especially streaming to several blocks at once will experiencea performance boost.When an on-disk block is deleted, it is removed from the block map and added to alist of wasted blocks. To recover wasted space, XBlockFile offers a Compact()function that re-creates the file without the wasted blocks.SUB-BLOCKS:Blocks can either contain raw data, or they can have a special flag set marking themas being merely a container for a block map with subordinate blocks. Thesesubordinate blocks are not listed in the file's block map (the root block map). Theblock map inside a container block looks and works just like the main block map,however it isn't followed by a list of wasted blocks, as the wasted list is sharedby all blocks and the root map.Sub blocks can in turn hold data or another block map. However, the data ofsub-blocks is not stored inside the containing block, rather, it may beanywhere inside the file, next to all other blocks. #endif