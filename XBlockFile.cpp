/*	***************************************************************************	PROJECT:	Joker		FILE:		XBlockFile.cpp		PURPOSE:	A block file for storing bits of information as				random-accessible blocks.			COPYRIGHT:	(C) Copyright 1999-2000 by M. Uli Kusterer, all rights reserved.				Subject to the FreeCard GPL derivate, see				http://freecard.sourceforge.net for details.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness		REVISIONS:		1999-08-14	UK		Began tracking wasted blocks in their own list.		1999-07-19	UK		Changed to use XEndianFile instead of ANSI FILE*.		1999-07-18	UK		Map is now a block of its own and may be anywhere							in the file, not just at the end. This makes for							more security as we can write a new map without							overwriting the old one and if an error occurs the							file remains valid.		1999-03-27	UK		Debugged file-saving and wrote compaction.		1999-03-25	UK		Did file-saving routines.		1999-03-24	UK		Created.	************************************************************************ */#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */#include	"XBlockFile.h"#pragma mark [Globals]/* --------------------------------------------------------------------------------	Globals/Static Variables:   ----------------------------------------------------------------------------- */// Put these li'l critters here.#pragma mark -#pragma mark [Init/Kill]/* --------------------------------------------------------------------------------	е CONSTRUCTOR:		Do some initialization.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */XBlockFile::XBlockFile()	: XEndianFile(){	mFileChanged = false;	mBusyProc = NULL;	mFileEnd = 0;		SetFileType( BLOCK_FILE_TYPE, BLOCK_FILE_CREATOR );	// Maps to no-op on platforms that don't need this.}/* --------------------------------------------------------------------------------	е CONSTRUCTOR:		Create this file with a filename and open it.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */XBlockFile::XBlockFile( char* inFileName )	: XEndianFile( inFileName ){	mFileChanged = false;	mBusyProc = NULL;	mFileEnd = 0;		SetFileType( BLOCK_FILE_TYPE, BLOCK_FILE_CREATOR );	// Maps to no-op on platforms that don't need this.}#pragma mark [Class Methods]/* --------------------------------------------------------------------------------	Open:		Open this file.			inAllowWrite	- boolean specifying whether you'd also like write permission.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::Open( bool inAllowWrite ){	XEndianFile::Open( inAllowWrite );		if( mFile && (mBlockMap.size() == 0) )		LoadBlockMap();	else		throw InternalError( __FILE__, "Open", "Map already loaded." );}/* --------------------------------------------------------------------------------	Close:		Close this file.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::Close(){	if( mFile )	{		if( mFileChanged )			SaveFile();		KillFileMap();				XEndianFile::Close();	}}/* --------------------------------------------------------------------------------	LoadBlocksIntoList:		Loads the blocks stored at the current mark location of our file into		the map passed. This calls itself recursively for any sub-blocks of		blocks it loads.		TAKES:		ioList		-	The list to load the blocks into.		forEntry	-	The entry whose map is ioList. This will be used to						set the mSuperEntry member of the loaded block entries.						Pass NULL for root blocks.		REVISIONS:		MM-02-10	UK		Made this set mSuperEntry.		1999-12-22	UK		Removed mFileEnd from here. Is now kept in file.		1999-11-15	UK		Made this eagerly evaluate mFileEnd.		1999-07-23	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::LoadBlocksIntoList( XBlockMap& ioList, XBlockEntry* forEntry ){	XBlockOffset		vMapEntryCount,						x;		// Get number of blocks ...	vMapEntryCount = ReadLong();		// ... and then loop so many times to read their entries from the disk:	for( x = 0; x < vMapEntryCount; x++ )	{		XBlockID		vBlockID;		XBlockEntry*	vCurrBlock;				vBlockID = ReadLong();	// Get ID:				vCurrBlock = &(ioList[vBlockID]);		vCurrBlock->mId = vBlockID;		vCurrBlock->mOffset = ReadLong();		vCurrBlock->mLength = ReadLong();		vCurrBlock->mLogLength = vCurrBlock->mLength;	// Physical vs. logical length only exists in RAM when streaming.		//vCurrBlock->mSubMapLength = ReadLong();	// obsolete.		vCurrBlock->mFlags = ReadChar();		vCurrBlock->mSuperEntry = forEntry;		vCurrBlock->mFile = this;				// Run user callback:		if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_LOAD, vMapEntryCount, x+1 );	// +1 since our counter is zero-based.	}}/* --------------------------------------------------------------------------------	LoadBlockMap:		Use the map offset in the header of this file to get at this file's map		and load it into a pointer so we can array-index it. The map is kept at		the end of the file, after the data, on disk. The RAM copy is then used to		keep track of any changes we make.				The file starts with 2 bytes that indicate the file version (file format),		1 byte of flags and then a 4-byte offset to the map. The map itself is		an array of XBlockEntry-like data with a 4-byte counter prefixed that		indicates the number of map entries.				To be guarded against un-clean files, we clear certain fields that are		only used in RAM, like the dirty and unsaved flags. 		REVISIONS:		1999-12-22	UK		Now reads file end from file.		1999-11-15	UK		Changed to eagerly evaluate file end.		1999-08-14	UK		Changed to use Red/Black tree indexed by size for							wasted blocks.		1999-07-??	UK		Added support for hierarchic blocks.		1999-03-27	UK		Fixed order of fseek params.		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::LoadBlockMap(){	XBlockFlags		vFileFlags;	unsigned short	vFileVersion;		// We're loading a new map, file can't be dirty:	mFileChanged = false;			// Make sure we're at file's start:	SetOffset( 0 );		// File isn't empty, is it?	if( GetLength() != 0 )	{		// Read file version to ensure file isn't too new:		vFileVersion = ReadShort();				if( vFileVersion == BLOCK_FILE_VERSION )	// Current version? еее DANGER!!! ENDIAN UN-AWARE! еее		{			// Read file flags:			vFileFlags = ReadChar();						// If not our endian, remember to swap:			#if MACINTOSH				SetEndianSwap( ((vFileFlags & FILE_FLAG_BIG_ENDIAN) != FILE_FLAG_BIG_ENDIAN) );				#else				SetEndianSwap( ((vFileFlags & FILE_FLAG_BIG_ENDIAN) == FILE_FLAG_BIG_ENDIAN) );			#endif						// Read file length:			mFileEnd = ReadLong();						// Read map offset:			mMapOffset = ReadLong();						// Go to the map offset:			SetOffset( mMapOffset );						// Now load this file's block map...			LoadBlocksIntoList( mBlockMap );						// ... and the list of wasted blocks:			LoadWastedIntoList();						// Now calculate size of map to ensure it's not overwritten:			mMapLength = GetOffset() -mMapOffset;		}		else			throw InternalError( __FILE__, "LoadBlockMap", "Unknown file format version." ); // Error!	}	else	// File empty? Make new empty map and write header to file.	{		mEndianSwapped = false;	// Use platform-native endian-ness.		WriteEmptyBlockFile();	// This ensures we have a proper map offset etc.	}}/* --------------------------------------------------------------------------------	LoadWastedIntoList:		Load list of wasted blocks into our size-keyed red/black tree.		REVISIONS:		1999-12-22	UK		Removed mFileEnd stuff again. Is now read from file.		1999-11-15	UK		Made this calculate mFileEnd in advance.		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::LoadWastedIntoList(){	XBlockOffset		vMapEntryCount,						x;		vMapEntryCount = ReadLong();	// Read # of wasted blocks.		for( x = 0; x < vMapEntryCount; x++ )	// Loop over them.	{		XBlockWastedSpace		vCurrEntry;				// Read wasted entry into a variable:		vCurrEntry.mOffset = ReadLong();		vCurrEntry.mLength = ReadLong();				// Add to wasted list in RAM:		mWastedBlocks.insert( XWastedListItem(vCurrEntry.mLength,vCurrEntry) );				if( mBusyProc )		// Call busy proc if defined.			(*mBusyProc)( BUSY_ACTION_LOAD_WASTED, vMapEntryCount, x+1 );	// +1 since counter is zero-based.	}}/* --------------------------------------------------------------------------------	WriteEmptyBlockFile:		Write a complete block file header to our file, including a 0 long to		indicate an empty map.		REVISIONS:		1999-03-28	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::WriteEmptyBlockFile(){	unsigned short		vVersion = BLOCK_FILE_VERSION;  #if MACINTOSH    XBlockFlags			vFlags = FILE_FLAG_BIG_ENDIAN;  #else	XBlockFlags			vFlags = 0;  #endif		/* This endian mode flag will be automatically converted to the opposite if		endian conversion is on: */		// Prepare our map entry:	mMapOffset = BLOCK_FILE_HEADER_SIZE;	mMapLength = sizeof(long) +sizeof(long);		// Write file version to identify the file's format:	WriteShort( vVersion );		// Write file flags:	WriteChar( vFlags );		// Write file end:	mFileEnd = mMapOffset +mMapLength;	WriteLong( mFileEnd );		// Write position of map:	WriteLong( mMapOffset );		// Write number of entries (none) in map:	WriteLong( 0 );		// Write number of wasted blocks (none) in map:	WriteLong( 0 );}/* --------------------------------------------------------------------------------	GetWastedBlockEntry:		Find the first wasted block that is large enough to hold a block of the		specified size.				inDesiredSize	- The size the block must have at least. The block might be						larger, so be prepared to split it or to adjust the logical						size.								Returns NULL if there is no wasted space or there's no contiguous wasted		block large enough.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */bool	XBlockFile::GetWastedBlockEntry( XBlockOffset inDesiredSize,											XBlockWastedSpace* outBlockSpace ){	XWastedIterator		iter;		iter = mWastedBlocks.lower_bound( inDesiredSize );	if( iter == mWastedBlocks.end() )		return false;	else	{		outBlockSpace = &iter->second;		return true;	}}/* --------------------------------------------------------------------------------	GetBlockEntry:		Loop over all blocks and look for a block of specified ID to then		return its block entry.				inID	- The ID of the block you're looking for. This must be a positive					integer.								Returns NULL if there is no block of specified ID.		REVISIONS:		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */XBlockEntry*	XBlockFile::GetBlockEntry( XBlockID inID ){	XBlockMapIterator		vIterator;		vIterator = mBlockMap.find( inID );	if( vIterator != mBlockMap.end() )	// Actually found something.		return &vIterator->second;	else		return NULL;}/* --------------------------------------------------------------------------------	GetBlock:		Return the data of a specified block. It is your resposibility to dispose		of the data this returns!				inID	- The ID of the block you're looking for. This must be a positive					integer.								This simply calls GetBlockEntry() and GetBlockData().		Returns NULL if there is no block of specified ID.		REVISIONS:		1999-03-31	UK		Created.   ----------------------------------------------------------------------------- */void*	XBlockFile::GetBlock( XBlockID inID ){	XBlockEntry*		vFoundEntry;		vFoundEntry = GetBlockEntry( inID );	if( vFoundEntry )		return GetBlockData( vFoundEntry );		return NULL;}/* --------------------------------------------------------------------------------	GetBlockData:		Return the data of a specified block. This is the actual data belonging		to the block.			TAKES:		vFoundEntry -	The block entry of the block you want to get the data from.		GIVES:		-		REVISIONS:		1999-06-19	UK		Created.   ----------------------------------------------------------------------------- */void*	XBlockFile::GetBlockData( XBlockEntry* vFoundEntry ){	// If the current block is not in RAM, load it:	if( vFoundEntry->mPointer == NULL )	{		vFoundEntry->mPointer = malloc( vFoundEntry->mLogLength );	// Make storage actual size of data.		if( vFoundEntry->mPointer != NULL )		{			vFoundEntry->mPointerLength = vFoundEntry->mLogLength;			SetOffset( vFoundEntry->mOffset );			// Move to block data start...			Read( vFoundEntry->mPointer, vFoundEntry->mLogLength );	// And read data from there into storage.						return vFoundEntry->mPointer;	// And return data.		}		else			throw MemoryError( __FILE__, "GetBlockData", "Couldn't allocate pointer for data." ); // Error!	}		return vFoundEntry->mPointer;	// Return the pointer.}/* --------------------------------------------------------------------------------	GetBlockToFile:		Return the data of a specified block. It is your resposibility to dispose		of the data this returns!			TAKES:		inID -		The ID of the block you're looking for. This must be a positive					integer.		inFile -	The file to write the data to.		GIVES:		-		REVISIONS:		1999-06-19	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::GetBlockToFile( XBlockID inID, FILE* inFile ){	XBlockEntry*		vFoundEntry;		vFoundEntry = GetBlockEntry( inID );	if( vFoundEntry )	{		/* See if we have to write block from RAM. If yes, we write it to the file			in one go: */		if( vFoundEntry->mPointer != NULL			&& ((vFoundEntry->mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY) )		{			Write( vFoundEntry->mPointer, vFoundEntry->mPointerLength );		}		else	// Else we copy the block over in chunks as blocks may be huge:		{			CopyBetweenFiles( mFile, inFile, vFoundEntry->mOffset, ftell( inFile ),										vFoundEntry->mLogLength );		}	}}/* --------------------------------------------------------------------------------	KillBlock:		Deletes a block from the file. This simply marks the block wasted using		WasteBlockEntry.		TAKES:		inID -		ID of block to waste.		GIVES:		-		REVISIONS:		1999-05-25	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::KillBlock( XBlockID inID ){	XBlockEntry*		vTheBlock;		vTheBlock = GetBlockEntry( inID );	WasteBlockEntry( vTheBlock );}/* --------------------------------------------------------------------------------	KillBlockEntry:		Deletes a block from the file. This simply marks the block wasted using		WasteBlockEntry.		TAKES:		inEntry		-	The block to waste.		GIVES:		-		REVISIONS:		2000-06-28	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::KillBlockEntry( XBlockEntry* inEntry ){	XBlockMap*		vMap;		// Get map this block belongs to:	if( inEntry->mSuperEntry == NULL )	// root block.		vMap = &mBlockMap;	else		vMap = (XBlockMap*) inEntry->mSuperEntry->mSubBlocks;		// Actually get rid of it:	WasteBlockEntry( inEntry, *vMap );}/* --------------------------------------------------------------------------------	WasteBlockEntry:		Mark the block file entry passed as wasted data. This means that the block		can be overwritten if its space is needed and it also means that it won't		be copied along if the file is compacted. This is as close as you can get		to deleting a block. This also frees this block's data in RAM if it has		been loaded and calls itself recursively on any sub blocks of this block.				inEntry		- The entry to mark as wasted. This must be one from our array						of entries.		inMap		- The map this block is listed in.								REVISIONS:		2000-07-28	UK		Made this delete its sub blocks.		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::WasteBlockEntry( XBlockEntry* inEntry, XBlockMap& inMap ){	// Delete our sub blocks if we have any:	if( (inEntry->mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )	{		XBlockMapIterator		vIterator;			if( inEntry->mSubBlocks == NULL )	// Map not yet loaded?			inEntry->mSubBlocks = GetSubBlockMap( inEntry );	// Load it now.				// Loop over it all and delete the blocks:		for( vIterator = ((XBlockMap*)inEntry->mSubBlocks)->begin(); vIterator != ((XBlockMap*)inEntry->mSubBlocks)->end(); ++vIterator )			WasteBlockEntry( &vIterator->second, (*(XBlockMap*)inEntry->mSubBlocks) );				// FIX ME! Doesn't the above loop need to use a reverse iterator? Consult the ANSI standard!	}		if( (inEntry->mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY )	// The block is RAM-only and hasn't been saved yet.	{		/* RAM-only blocks are simply deleted, as they have no section in the file which			they can serve as a placeholder for. */		KillMapEntry( inEntry, inMap );	}	else	{		XBlockWastedSpace		vWastedEntry;				// Set up a "wasted space" entry that keeps track of the space formerly occupied by the block:		vWastedEntry.mOffset = inEntry->mOffset;		vWastedEntry.mLength = inEntry->mLength;				/* Add it to our wasted list:			We don't add this to mWastedBlocks as a safety measure. Blocks from mNewlyWastedBlocks			are not overwritten until the next successful save, which is when the two lists are			unified. This means we do not overwrite any important data until we have a new valid			file. */		mNewlyWastedBlocks.insert( XWastedListItem(inEntry->mLength,vWastedEntry) );				KillMapEntry( inEntry, inMap );	// Now get rid of block entry so it doesn't fight with wasted entry.		mFileChanged = true;	}}/* --------------------------------------------------------------------------------	KillMapEntry:		Delete a map entry from the block file's map. The caller has to make sure		the data pointed to by this entry is taken over by some other block etc.		or you'll have a hole in your file which can't be re-used until the file		is compacted.			WARNING:	Your pointers to any blocks might become invalid after calling				this as this can change the order of some blocks.		TAKES:		inEntry -	A pointer to the entry to be deleted.		GIVES:		-								REVISIONS:		1999-09-26	UK		Changed to use new XBlockEntry class.		1999-06-23	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::KillMapEntry( XBlockEntry* inEntry, XBlockMap& inMap ){	inMap.erase( inEntry->mId );}/* --------------------------------------------------------------------------------	SaveFile:		Write the block data and map we keep in RAM to the file.		REVISIONS:		1999-12-22	UK		Now saves mFileEnd in file after calculating it.		1999-11-15	UK		Made this update pre-calculated mFileEnd value.		1999-11-05	UK		Finished adapting this to separate block & wasted							lists.		1999-09-26	UK		Changed to use new XBlockEntry class.		1999-07-18	UK		Map is now a block, too.		1999-05-06	UK		Fixed bug in flag setting.		1999-03-25	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::SaveFile(){	XBlockOffset	x = 0,					vFileEnd = CalculateFileEnd(),					vMapEntryCount = mBlockMap.size();		// ----- Loop over all blocks and write down their data: -----	for( XBlockMapIterator iterator = mBlockMap.begin(); iterator != mBlockMap.end(); ++iterator )	{		if( (iterator->second.mFlags & BLOCK_DIRTY) == BLOCK_DIRTY		// Need to save.			&& (iterator->second.mFlags & BLOCK_RAM_ONLY) == 0 )		// Is already on disk.		{			if( (iterator->second.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )	// Has sub blocks:				WriteBlockMap( (*(XBlockMap*) iterator->second.mSubBlocks), iterator->second.mOffset,  vFileEnd );			else	// Just write down data.			{				SetOffset( iterator->second.mOffset );				Write( iterator->second.mPointer, iterator->second.mPointerLength );			}						iterator->second.mFlags &= ~BLOCK_DIRTY;	// Clear dirty flag.		}		else if( (iterator->second.mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY )		// New block!		{			// Make sure block knows where it's gone:			iterator->second.mLogLength = iterator->second.mPointerLength;			iterator->second.mLength = iterator->second.mPointerLength;			iterator->second.mOffset = vFileEnd;						// Actually write. Happens second in case WriteBlockMap() changes vFileEnd.			if( (iterator->second.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )	// Has sub blocks:				iterator->second.mOffset = WriteBlockMap( (*(XBlockMap*) iterator->second.mSubBlocks), 0, vFileEnd );			else			{				SetOffset( vFileEnd );				Write( iterator->second.mPointer, iterator->second.mPointerLength );			}						vFileEnd += iterator->second.mLength;		// Move vFileEnd past newly written block.			iterator->second.mFlags &= ~BLOCK_RAM_ONLY;	// Clear dirty and 'not on disk' flags.			iterator->second.mFlags &= ~BLOCK_DIRTY;		}				// Dispose of RAM data:		iterator->second.UnloadData();				if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_SAVE_DATA, vMapEntryCount, ++x );	}		// ------- Write map to file: -------		// First try to find a wasted block we can write map in:	XBlockWastedSpace		vMapEntryPlace,							vOldMapEntryPlace;	XBlockOffset			vMapSize = sizeof(XBlockOffset)										+(mBlockMap.size() *DISK_BLOCK_ENTRY_SIZE)										+sizeof(XBlockOffset)										+((mWastedBlocks.size() +mNewlyWastedBlocks.size()) * DISK_WASTE_ENTRY_SIZE);	bool					vSuccess;		/* Try to get wasted space that's large enough to hold all block entries and		all wasted entries plus their "count" fields. */	vSuccess = GetWastedBlockEntry( vMapSize, &vMapEntryPlace );	if( vSuccess )	{		SetOffset( vMapEntryPlace.mOffset );	// On error here, file is invalid !				/* Delete wasted entry whose space we now use for map.			We needn't adjust vMapSize because we'll later waste the old map			which will add another wasted entry again to take this one's place. */		mWastedBlocks.erase( vMapSize );	}	else	// We need completely new block at end for map:	{		SetOffset( vFileEnd );	// On error here, file is invalid !				vMapSize += DISK_WASTE_ENTRY_SIZE;	// Adjust vMapSize, since below we'll add an entry for the old map.				vMapEntryPlace.mOffset = vFileEnd;		vMapEntryPlace.mLength = vMapSize;	}		// Remember old map location:	vOldMapEntryPlace.mOffset = mMapOffset;	vOldMapEntryPlace.mLength = mMapLength;		/* Now make old map wasted. If this save fails, the file will still be valid anyway		since the changed map's position hasn't been written yet, and the map offset		still points to the old map. If it succeeds the old map will look like any other		wasted block. */	mNewlyWastedBlocks.insert( XWastedListItem(vOldMapEntryPlace.mLength,vOldMapEntryPlace) );		// Write map entry count to new map block:	WriteLong( vMapEntryCount );		// Now we write the actual map:	x = 0;		for( XBlockMapIterator svIterator = mBlockMap.begin(); svIterator != mBlockMap.end(); ++svIterator )	{		// FIX ME! Shouldn't this call block's WriteToFile() ?		WriteLong( svIterator->second.mId );		WriteLong( svIterator->second.mOffset );		WriteLong( svIterator->second.mLength );		//WriteLong( svIterator->second.mLogLength );	// Only exists in RAM.		//WriteLong( svIterator->second.mSubMapLength );	// Obsolete.		WriteChar( svIterator->second.mFlags );				if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_SAVE_MAP, vMapEntryCount, ++x );	}		// Write wasted block count to new map block:	XBlockOffset	vWastedCount = mWastedBlocks.size() +mNewlyWastedBlocks.size();	WriteLong( vWastedCount );		// Now we write the list of wasted blocks:	XWastedIterator		vIterator;		x = 0;	for( vIterator = mWastedBlocks.begin(); vIterator != mWastedBlocks.end(); vIterator++ )	{		WriteLong( vIterator->second.mOffset );		WriteLong( vIterator->second.mLength );				if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_SAVE_WASTED, vWastedCount, ++x );	}		x = mWastedBlocks.size();		for( vIterator = mNewlyWastedBlocks.begin(); vIterator != mNewlyWastedBlocks.end(); vIterator++ )	{		WriteLong( vIterator->second.mOffset );		WriteLong( vIterator->second.mLength );				if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_SAVE_WASTED, vWastedCount, ++x );	}		// Now write map offset to start of file:	SetOffset( BLOCK_FILE_HEADER_MAPOFFS_OFFSET );	WriteLong( vMapEntryPlace.mOffset );		// Update members reflecting location/size of on-disk map:	mMapOffset = vMapEntryPlace.mOffset;	mMapLength = vMapEntryPlace.mLength;		mFileEnd = vFileEnd +mMapLength;	// Remember new end of file.		// Write down mFileEnd:	SetOffset( BLOCK_FILE_HEADER_FILEEND_OFFSET );	WriteLong( mFileEnd );		mWastedBlocks.insert( mNewlyWastedBlocks.begin(), mNewlyWastedBlocks.end() );	mNewlyWastedBlocks.erase( mNewlyWastedBlocks.begin(), mNewlyWastedBlocks.end() );		// File is now in sync with disk again:	mFileChanged = false;}/* --------------------------------------------------------------------------------	WriteBlockMap:		Write a block map to the file at the current mark.			TAKES:		vTheMap		-	XBlockMap whose contents we are to write. This will						recursively write sub block's maps if they have any.		vFileEnd	-	The file's end. This will be updated by this function if						necessary.		GIVES:		XBlockOffset	-	Offset where the map was written to.		REVISIONS:		2000-01-28	UK		Created.   ----------------------------------------------------------------------------- */XBlockOffset	XBlockFile::WriteBlockMap( XBlockMap& vTheMap, XBlockOffset vBlockOffs,											XBlockOffset &vFileEnd ){	XBlockOffset	x = 0,					vMapEntryCount = vTheMap.size();		// ----- Loop over all blocks and write down their data: -----	for( XBlockMapIterator iterator = vTheMap.begin(); iterator != vTheMap.end(); ++iterator )	{		XBlockEntry&	vCurrEntry = iterator->second;				if( (vCurrEntry.mFlags & BLOCK_DIRTY) == BLOCK_DIRTY				// Need to save.			&& (vCurrEntry.mFlags & BLOCK_RAM_ONLY) != BLOCK_RAM_ONLY )	// Is already on disk.		{			if( (vCurrEntry.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )	// Has sub blocks:				WriteBlockMap( (*(XBlockMap*) vCurrEntry.mSubBlocks), vCurrEntry.mOffset, vFileEnd );			else	// No need to pass size returned above, is pre-calculated when map is changed in RAM.			{	// Else just write data:				SetOffset( vCurrEntry.mOffset );				Write( vCurrEntry.mPointer, vCurrEntry.mPointerLength );			}						/* If this block contains more space for streaming, now's the				time to waste it:				By wasting it we needn't save both logical and physical length, saving				4 bytes per block. Since FluffBlock() looks for streaming space following				a block we can even recover it. */			if( vCurrEntry.mLength > vCurrEntry.mLogLength )			{				XBlockWastedSpace		vWastedEntry;								vWastedEntry.mLength = vCurrEntry.mLength -vCurrEntry.mLogLength;				vWastedEntry.mOffset = vCurrEntry.mOffset -vWastedEntry.mLength;								mNewlyWastedBlocks.insert( XWastedListItem(vWastedEntry.mLength,vWastedEntry) );							vCurrEntry.mLength = vCurrEntry.mLogLength;			}						vCurrEntry.mFlags &= ~BLOCK_DIRTY;	// Clear dirty flag.		}		else if( (iterator->second.mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY )		// New block!		{			// Make sure block knows where it's gone:			vCurrEntry.mLogLength = vCurrEntry.mPointerLength;			vCurrEntry.mLength = vCurrEntry.mPointerLength;			vCurrEntry.mOffset = vFileEnd;						/* Now actually write it:				We can't write block map before changing mOffset since WriteBlockMap()				changes vFileEnd. */			if( (vCurrEntry.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )	// Has sub blocks:				vCurrEntry.mOffset = WriteBlockMap( (*(XBlockMap*) vCurrEntry.mSubBlocks), 0, vFileEnd );			else	// No need to pass size above, is pre-calculated when map is changed in RAM.			{				SetOffset( vFileEnd );				Write( vCurrEntry.mPointer, vCurrEntry.mPointerLength );			}						vFileEnd += vCurrEntry.mLength;			// Move vFileEnd past newly written block.			vCurrEntry.mFlags &= ~BLOCK_RAM_ONLY;	// Clear dirty and 'not on disk' flags.			vCurrEntry.mFlags &= ~BLOCK_DIRTY;		}				// Dispose of RAM data:		if( (vCurrEntry.mFlags & BLOCK_PURGEABLE) == BLOCK_PURGEABLE )			vCurrEntry.UnloadData();				if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_SAVE_DATA, vMapEntryCount, ++x );	}		// ------- Write map to file: -------	if( vBlockOffs == 0 )	// This map block is new!		vBlockOffs = vFileEnd;	// Append it to our file.	SetOffset( vBlockOffs );		// Write map entry count to this block:	WriteLong( vMapEntryCount );		// Now we write the actual map:	x = 0;		for( XBlockMapIterator svIterator = vTheMap.begin(); svIterator != vTheMap.end(); ++svIterator )	{		svIterator->second.WriteToFile( *this );				if( mBusyProc )			(*mBusyProc)( BUSY_ACTION_SAVE_MAP, vMapEntryCount, ++x );	}		return vBlockOffs;}/* --------------------------------------------------------------------------------	Compact:		This removes any wasted space from this file by writing everything except		wasted space to a new file and then swapping the file names and deleting		the original one.		REVISIONS:		2000-06-27	UK		Fixed bugs in calculating file size.		2000-06-26	UK		Fixed map position that was calculated wrongly.		1999-11-15	UK		Made this update mFileEnd accordingly.		1999-04-03	UK		Added exceptions.		1999-04-02	UK		Fixed loads of bugs.		1999-03-27	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::Compact(){	XEndianFile			tempFile;	char				fileName[MAX_FILENAME_SIZE],						oldName[MAX_FILENAME_SIZE];	XBlockMap			theMap;		if( mBlockMap.size() == 0 )		return;		// Generate a nice filename for our temp file by appending a suffix:	strcpy( fileName, mFileName );	strncat( fileName, ".occ", MAX_FILENAME_SIZE );	strcpy( oldName, mFileName );	Rename( fileName );		// Create a new destination file:	tempFile.SetFileName(oldName);	tempFile.Open(true);	tempFile.SetEndianSwap( GetEndianSwap() );	// FIX ME! еее Compact should force native endian-ness еее	tempFile.SetFileType( BLOCK_FILE_TYPE, BLOCK_FILE_CREATOR );	// Maps to no-op on platforms that don't need this.		// Make header for an empty file:	tempFile.WriteShort( BLOCK_FILE_VERSION );	#if MACINTOSH	tempFile.WriteChar( FILE_FLAG_BIG_ENDIAN );	// Flags.	#else	tempFile.WriteChar( 0 );	// Flags.	#endif	tempFile.WriteLong( BLOCK_FILE_HEADER_SIZE +sizeof(XBlockOffset) *2 );	// File's end to be filled in later.	tempFile.WriteLong( BLOCK_FILE_HEADER_SIZE );	// Map Offset.	tempFile.WriteLong( 0 );	// Map entry count. 0 should be OK, and if not we're overwriting it anyway.	tempFile.WriteLong( 0 );	// Wasted entry count. 0 should be OK, ...		XBlockOffset	vCurrWritePosition = BLOCK_FILE_HEADER_SIZE;	// Start just after header.		CompactBlockMap( mBlockMap, vCurrWritePosition, tempFile, theMap );		// Now save our file's map:	XBlockOffset		vNewMapOffset = vCurrWritePosition,						vNewMapLength;	vNewMapLength = StoreOneMapWithoutData( theMap, vCurrWritePosition, tempFile );	vCurrWritePosition += vNewMapLength;	// Advance past the map so file size is reflected right.		tempFile.WriteLong( 0 );	// We have no wasted blocks, this is a compacted file!	vCurrWritePosition += sizeof(XBlockOffset);		// Now write offset of map to file:	tempFile.SetOffset( BLOCK_FILE_HEADER_MAPOFFS_OFFSET );	// Go to field that holds map offset.	tempFile.WriteLong( vNewMapOffset );		mMapLength = vNewMapLength;	// Make sure map size variable is valid.	mFileEnd = vCurrWritePosition;	// make sure our file's end variable is valid.		// Now write down file end:	tempFile.SetOffset( BLOCK_FILE_HEADER_FILEEND_OFFSET );	// Go to field that holds file end.	tempFile.WriteLong( mFileEnd );		// Close & kill our old file	fclose( mFile );	remove( fileName );		// Take over temp file's file:	mFile = tempFile.StealFile();		// Kill wasted list:	mWastedBlocks.erase( mWastedBlocks.begin(), mWastedBlocks.end() );	mNewlyWastedBlocks.erase( mNewlyWastedBlocks.begin(), mNewlyWastedBlocks.end() );		// Transfer entries to new map:	KillFileMap();	mBlockMap.swap( theMap );	// FIX ME! Make sure this also re-assigns the mSuperEntry if needed!		mFileChanged = false;	// File matches disk version now.}/* --------------------------------------------------------------------------------	StoreOneMapWithoutData:		Writes solely the specified map itself to a specified file at the		specified offset. Returns the length (in bytes) of the map written.		The data of the blocks is not written. Used during compacting.		TAKES:		theMap			-	The XBlockMap to write.		vWritePos		-	The offset into the file where the map is to be							written.		destFile		-	The file to which the map is to be written			GIVES:		XBlockOffset	-	The length (in bytes) the map uses in the file.		REVISIONS:		2000-06-27	UK		Made this include size of count in returned size.		2000-05-08	UK		Created.   ----------------------------------------------------------------------------- */XBlockOffset	XBlockFile::StoreOneMapWithoutData( XBlockMap& theMap, XBlockOffset vWritePos,													XEndianFile& destFile ){	XBlockOffset		vNewMapOffset = vWritePos;	// Remember old value so we can calc length later.		// Write count of map's blocks:	destFile.SetOffset( vWritePos );	destFile.WriteLong( theMap.size() );	vWritePos += sizeof(XBlockOffset);		// Now write map entries:	for( XBlockMapIterator iteratorTwo = theMap.begin(); iteratorTwo != theMap.end(); ++iteratorTwo )	{		iteratorTwo->second.WriteToFile( destFile );		vWritePos += DISK_BLOCK_ENTRY_SIZE;	}		return( vWritePos -vNewMapOffset );}/* --------------------------------------------------------------------------------	CompactBlockMap:		Compact a block map and write the data of that map's blocks and sub		blocks (but only sub-block's maps, not this map) to the file.				Called by Compact() to compact the global or a sub-block's map. This		also saves and re-arranges the data on disk.			TAKES:		srcMap	-				The old, uncompacted map. Offsets in here must								refer to data in The file referred to by mFile.		vCurrWritePosition	-	The offset to start writing data to.		tempFile	-			The file to write the new data to.			GIVES:		dstMap	-				This block map which will be set to the new,								compacted block map. *must* be empty!		REVISIONS:		2000-06-27	UK		Fixed block offset when writing sub block lists.		1999-03-28	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::CompactBlockMap( XBlockMap &srcMap, size_t &vCurrWritePosition,										XEndianFile& tempFile, XBlockMap& dstMap ){	// Now read from tempFile using mFileMap and write to mFile.	//	We'll need to create a second copy of the map in RAM so	//	we can write it to mFile later.	for( XBlockMapIterator iterator = srcMap.begin(); iterator != srcMap.end(); ++iterator )	{		tempFile.SetOffset( vCurrWritePosition );	// Needed since we must obliterate the zeroes above.				XBlockEntry&		vCurrEntry = iterator->second;		XBlockEntry*		vTemplate;				vTemplate = &(dstMap[vCurrEntry.mId]);	// vTemplate is pointer to the new entry.				(*vTemplate) = vCurrEntry;							// Copy attributes from original block.		vTemplate->mFlags &= ~VOLATILE_BLOCK_FLAGS_MASK;	// Clear flags that only make sense in RAM. It's no longer RAM-only or dirty.		vTemplate->mOffset = vCurrWritePosition;			// Have it start at earliest possible point in new file.		vTemplate->mFile = this;				// If the block is already in RAM we write RAM data to compacted file:		if( (vCurrEntry.mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY			|| (vCurrEntry.mFlags & BLOCK_DIRTY) == BLOCK_DIRTY )		{			if( (vCurrEntry.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )			{				XBlockMap		vNewMap;								CompactBlockMap( (*(XBlockMap*)vCurrEntry.mSubBlocks), vCurrWritePosition,									tempFile, vNewMap );								/* Now write compacted map to file:					This also makes sure the block is just as long as the map. */				vTemplate->mOffset = vCurrWritePosition;	// Else we'd overwrite CompactBlockMap's block data.				vTemplate->mLength = StoreOneMapWithoutData( vNewMap, vTemplate->mOffset, tempFile );				vTemplate->mLogLength = vTemplate->mLength;			}			else			{				vTemplate->mLength = vCurrEntry.mPointerLength;						// Length is logical length.				vTemplate->mLogLength = vCurrEntry.mPointerLength;					// Logical & physical length equal.				tempFile.Write( vTemplate->mPointer, vTemplate->mPointerLength );	// Write block's data to file.			}		}		else	// Else copy from file:		{			if( (vCurrEntry.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )			{				XBlockMap		*vOldMap,								vNewMap;				bool			killMap = false;								// If map isn't loaded yet, load it temporarily:				if( vCurrEntry.mSubBlocks == NULL )				{					vOldMap = GetSubBlockMap( &vCurrEntry );					killMap = true;				}				else					vOldMap = (XBlockMap*) vCurrEntry.mSubBlocks;								CompactBlockMap( *vOldMap, vCurrWritePosition, tempFile, vNewMap );								/* Now write compacted map to file:					This also makes sure the block is just as long as the map. */				vTemplate->mOffset = vCurrWritePosition;	// Else we'd overwrite CompactBlockMap's block data.				vTemplate->mLength = StoreOneMapWithoutData( vNewMap, vTemplate->mOffset, tempFile );				vTemplate->mLogLength = vTemplate->mLength;								if( killMap )	// Temporary map? Dispose to save RAM:					delete vOldMap;			}			else			{				vTemplate->mLength = vTemplate->mLogLength;	// Don't waste any space, make physical length equal logical.				CopyBetweenFiles( mFile, tempFile.GetFile(), vCurrEntry.mOffset, vTemplate->mOffset,									vTemplate->mLength );	// Copy data between files (this works with low RAM, too).			}		}				vCurrWritePosition += vTemplate->mLength;	// Advance position to start next block at.	}}/* --------------------------------------------------------------------------------	KillFileMap:		Dispose of the file map and all the data handles in there.		REVISIONS:		1999-05-06	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::KillFileMap(){	mBlockMap.erase( mBlockMap.begin(), mBlockMap.end() );	// Kill all.}/* --------------------------------------------------------------------------------	SplitBlock:		Split the on-disk block specified into two blocks, of which one has the		size specified. A new block will be created that points to the remaining		data in the file. This is used by SetBlock() when taking over wasted		blocks, and by the streaming code when inserting data.				inEntry			- The entry to become the specified size.		inDesiredSize	- The length to assign to inEntry.				Returns a pointer to the block that was created.			WARNING:	Do not use this on RAM-only blocks! (Loaded but already saved				blocks are fine as long as you resize the pointer accordingly.								REVISIONS:		1999-03-25	UK		Created.   ----------------------------------------------------------------------------- */XBlockEntry*	XBlockFile::SplitBlock( XBlockEntry* inEntry, XBlockOffset inDesiredSize ){#pragma unused(inEntry)#pragma unused(inDesiredSize)	/*	XBlockEntry				vTemplate,							*vReturnBlock;		vReturnBlock = NULL;		vTemplate.id = 8317;	vTemplate.offset = inEntry->offset +inDesiredSize;	vTemplate.length = inEntry->length -inDesiredSize;	vTemplate.logLength = inEntry->length -inDesiredSize;	vTemplate.pointer = NULL;	vTemplate.pointerLength = 0;	vTemplate.flags = BLOCK_WASTED;		vReturnBlock = MakeNewMapEntry( &vTemplate );	// Create entry to take care of data we got rid of.		if( vReturnBlock == NULL )		throw XBlockFileAnyException(); // Error!			inEntry->length = inDesiredSize;	// Make our block smaller now that excess space is taken care of.	inEntry->logLength = inDesiredSize;	inEntry->pointerLength = inDesiredSize;		mFileChanged = true;	// We just added a block to the map.			return vReturnBlock;	*/  	printf( "Error: SplitBlock called." );		return NULL;}/* --------------------------------------------------------------------------------	CalculateFileEnd:		Add up the lengths of all blocks that are marked as 'on disk' in the RAM		block map and of all wasted blocks and add the header's length to that.		The offset this results in can then be used to determine a place where new		data (resp. the map) can be written to. Used extensively by SaveFile().				This can also be used to determine where to write new blocks, if you		clear the new block's 'not on disk' flag after writing it so it will be		considered by this next time you call it.				WARNING:	Currently this returns incorrect results if the file contains					"holes" for which no block entry and no wasted entry exists!					This also doesn't take into account sub-blocks.								REVISIONS:		1999-11-15	UK		This is now calculated once at start-up and then							simply returned ("eager evaluation") to speed things							up.		1999-10-18	UK		Changed to reflect separate list for wasted blocks.		1999-03-25	UK		Created.   ----------------------------------------------------------------------------- */XBlockOffset	XBlockFile::CalculateFileEnd(){	/*	XBlockOffset	vFileLength = BLOCK_FILE_HEADER_SIZE;		// Add up block map:	for( XBlockMapIterator iterator = mBlockMap.begin(); iterator != mBlockMap.end(); ++iterator )	{		if( (iterator->second.mFlags & BLOCK_RAM_ONLY) != BLOCK_RAM_ONLY )	// Is on-disk block.			vFileLength += iterator->second.mLength;	}		// Add up wasted blocks:	XRedBlackTree<unsigned long,XBlockWastedSpace>::XRBIterator*		vIterator;		vIterator = mWastedBlocks.first();	while( !(vIterator->end()) )	{		++(*vIterator);				if( !(vIterator->end()) )			vFileLength = vIterator->currRec().mLength;	}		delete vIterator;		vFileLength += mMapLength;		return vFileLength; */		return mFileEnd;}/* --------------------------------------------------------------------------------	SetBlock:		Create a new root block of specified ID. If there is already such a		block, it will be replaced.				inID		- The ID for the new block. This must be a positive integer.		inData		- A pointer to the data you want to have written to the block.		inLength	- The length of the data to write to the block.								REVISIONS:		1999-10-21	UK		Changed to use separate map entry and wasted lists.		1999-03-24	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::SetBlock( XBlockID inID, void* inData,								XBlockOffset inLength ){	AddBlockToMap( mBlockMap, inID, inData, inLength );	// No need to set the new block's mSuperEntry as it's a root block.}/* --------------------------------------------------------------------------------	AddBlockToMap:		Create a new block of specified ID in the specified block map. If there is		already such a block, it will be replaced.				inMap		- The map to add the block to.		inID		- The ID for the new block. This must be a positive integer.		inData		- A pointer to the data you want to have written to the block.		inLength	- The length of the data to write to the block.								REVISIONS:		MM-02-05	UK	Changed to also take inMap argument.		1999-10-21	UK	Changed to use separate map entry and wasted lists.		1999-03-24	UK	Created.   ----------------------------------------------------------------------------- */XBlockEntry*	XBlockFile::AddBlockToMap( XBlockMap& inMap, XBlockID inID, void* inData,								XBlockOffset inLength ){	XBlockEntry*			vTheEntry = NULL;	XBlockWastedSpace		vSpace;	XBlockMapIterator		vIterator;		// Delete any existing blocks with same attributes:	vIterator = inMap.find( inID );	if( vIterator != inMap.end() )	// Actually found something.		WasteBlockEntry( &vIterator->second, inMap );		// Look for an unused block which we can take over:	bool vHaveWasted = GetWastedBlockEntry( inLength, &vSpace );	// Found one! Is deleted below.		// Make new block entry:	vTheEntry = &(inMap[inID]);		vTheEntry->mFile = this;	vTheEntry->mPointer = malloc( inLength );	// XBlockEntry is initially with NULL mPointer. We may smash.	if( !vTheEntry->mPointer )		throw MemoryError( __FILE__, "SetBlock", "Couldn't allocate pointer for data." ); // Error!		memcpy( vTheEntry->mPointer, inData, inLength );	// Copy data to block.	vTheEntry->mPointerLength = inLength;	vTheEntry->mId = inID;	vTheEntry->mFlags = BLOCK_DIRTY;	// Mark block dirty.	vTheEntry->mLogLength = inLength;	// Set logical length to length of actual data.		if( vHaveWasted )	// We have a place on disk where this is written:	{		vTheEntry->mOffset = vSpace.mOffset;		vTheEntry->mLength = vSpace.mLength;		mWastedBlocks.erase( inLength );	// Delete the wasted entry.	}	else	// We'll decide where to put this when we're saving.	{		vTheEntry->mOffset = NULL;		vTheEntry->mLength = 0;		vTheEntry->mFlags |= BLOCK_RAM_ONLY;	}		mFileChanged = true;		return vTheEntry;}/* --------------------------------------------------------------------------------	ResizeBlockEntry:		Resize the data of the specified block. Do this instead of calling realloc		on the block's data pointer, since there's more involved than that.				vTheEntry	- A pointer to the block entry you'd like to resize.		inLength	- The new length for the block.								REVISIONS:		2000-01-20	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::ResizeBlockEntry( XBlockEntry* vTheEntry, XBlockOffset inLength ){	void*		vDataPtr;		// If RAM-only block, just realloc at larger size:	if( (vTheEntry->mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY )	{		if( vTheEntry->mPointer == NULL )	// New block? Allocate empty data:		{			vTheEntry->mPointer = malloc( inLength );			if( vTheEntry->mPointer == NULL )				throw MemoryError( __FILE__, "ResizeBlockEntry", "Couldn't allocate data pointer." );			vTheEntry->mPointerLength = inLength;		}		else	// Has data? Resize data pointer:		{			vDataPtr = realloc( vTheEntry->mPointer, inLength );			if( vDataPtr )			{				vTheEntry->mPointer = vDataPtr;				vTheEntry->mPointerLength = inLength;			}			else				throw MemoryError( __FILE__, "ResizeBlockEntry", "Couldn't resize data pointer in RAM." );		}		return;	}		XBlockWastedSpace		vSpace;		if( vTheEntry->mPointer == NULL )	// Block not in RAM?	{		FluffBlock( vTheEntry, inLength -vTheEntry->mLogLength );	// FluffBlock takes care of this.	}	else	// Block in RAM and on disk?	{		// Set up a "wasted space" entry that keeps track of the space formerly occupied by the block:		vSpace.mOffset = vTheEntry->mOffset;		vSpace.mLength = vTheEntry->mLength;		mWastedBlocks.insert( XWastedListItem(vTheEntry->mLength,vSpace) );				mFileChanged = true;				// Look for an unused block which we can take over:		bool vHaveWasted = GetWastedBlockEntry( inLength, &vSpace );	// Found one! Is deleted below.		vTheEntry->mFile = this;	// Make sure entry's owner field is right.				// Try to enlarge RAM data of block:		vDataPtr = realloc( vTheEntry->mPointer, inLength );		if( vDataPtr )		{			vTheEntry->mPointer = vDataPtr;			vTheEntry->mPointerLength = inLength;		}		if( !vTheEntry->mPointer )			throw MemoryError( __FILE__, "ResizeBlockEntry", "Couldn't reallocate pointer for data." ); // Error!				vTheEntry->mFlags = BLOCK_DIRTY;	// Mark block dirty.		vTheEntry->mLogLength = inLength;	// Set logical length to length of actual data.				if( vHaveWasted )	// We have a place on disk where this is written:		{			vTheEntry->mOffset = vSpace.mOffset;			vTheEntry->mLength = vSpace.mLength;			mWastedBlocks.erase( inLength );	// Delete the wasted entry.		}		else	// We'll decide where to put this when we're saving.		{			vTheEntry->mOffset = 0;			vTheEntry->mLength = 0;			vTheEntry->mFlags |= BLOCK_RAM_ONLY;		}	}}/* --------------------------------------------------------------------------------	SetBlockFromFile:		Create a new block of specified ID. If there is already such a		block, it will be replaced.				inID		- The ID for the new block. This must be a positive integer.		inFile		- A file containing data to be written to this block.								REVISIONS:		1999-06-18	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::SetBlockFromFile( XBlockID inID, FILE* inFile ){	XBlockEntry*		vTheEntry;	size_t				vLength;		if( fseek( inFile, 0, SEEK_END ) != 0 )		throw InternalError( __FILE__, "SetBlockFromFile", "Couldn't determine size of input file." );	vLength = ftell( inFile );		// Look for a block with our attributes:	vTheEntry = GetBlockEntry( inID );	if( vTheEntry )		// Already have such a block!		WasteBlockEntry( vTheEntry );	// Get rid of the block.		// Look for an unused block which we can take over:	XBlockWastedSpace		vSpace;		// Look for an unused block which we can take over:	bool vHaveWasted = GetWastedBlockEntry( vLength, &vSpace );	// Found one! Is deleted below.		XBlockEntry*		vNewEntry;		vNewEntry = &(mBlockMap[inID]);	vNewEntry->mFile = this;		// Set up block entry:	vNewEntry->mId = inID;	vNewEntry->mFlags = 0;				// Mark block dirty and kill any wasted etc. flags.	vNewEntry->mLogLength = vLength;	// Make logical length match length of data.		if( vHaveWasted )	// We have a place on disk where this is written:	{		vNewEntry->mOffset = vSpace.mOffset;		vNewEntry->mLength = vSpace.mLength;		mWastedBlocks.erase( vLength );	// Delete the wasted entry.	}	else	{		vNewEntry->mOffset = CalculateFileEnd();		vNewEntry->mLength = vLength;				mFileEnd += vLength;	// make sure file's end is now behind our block.	}		CopyBetweenFiles( inFile, mFile, 0, vNewEntry->mOffset, vLength );	// Actually copy data between files.		mFileChanged = true;	// Because map needs to be updated!}/* --------------------------------------------------------------------------------	FluffBlock:		Enlarges a block's physical size (and possibly re-creates it at the end		of the file to achieve this) while keeping its logical size untouched.		This is used to request enough space to stream data to a block. Note that		this won't do anything if the block's physical size is already as much		larger as its logical size as you requested.				This tries to find a wasted block after the current one, and if it finds		one uses that, else it moves the block to the end of the file and enlarges		it there.				By using this before streaming to a file you can significantly speed up		streaming as you can resize the block in one great swoop instead of		having frequent disk access slow down streaming too much.		NOTE:		There's a penalty every time you use this call as it may involve				moving a huge block to the end of the file. It is better to fluff				a block by 2000 bytes once than to fluff it 1000 times by 2.			TAKES:		inBlock -		The block to resize.		inAmount -		Additional amount of data needed. This is added to the						block's logical size to calculate the desired new block						size.		GIVES:		-								REVISIONS:		1999-06-23	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::FluffBlock( XBlockEntry* inBlock, size_t inAmount ){	XBlockEntry*			vTheBlock;	XBlockOffset			vDesiredStart;		// First, we needn't handle blocks that are in RAM this way:	if( (inBlock->mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY		|| (inBlock->mFlags & BLOCK_DIRTY) == BLOCK_DIRTY )		return;		// Now, check whether block is already large enough:	if( (inBlock->mLogLength +inAmount) <= inBlock->mLength )		return;		vDesiredStart = inBlock->mOffset +inBlock->mLength;	// Calc end of this block.		if( vDesiredStart >= CalculateFileEnd() )		// This is the last block?	{		inBlock->mLength += inAmount;		SetLength( GetLength() +inAmount );	// Enlarge file.		mFileEnd += inAmount;		mFileChanged = true;		return;	}		/* Look for wasted block following our block we can re-use to enlarge ours:		Currently this checks only one block after this block. Anybody want to improve this? */	XWastedIterator		vIterator;		for( vIterator = mWastedBlocks.begin(); vIterator != mWastedBlocks.end(); vIterator++ )	{		if( vIterator->second.mOffset == vDesiredStart )		// Found wasted block after this!		{			if( (inBlock->mLength -inBlock->mLogLength +vIterator->second.mLength) >= inAmount )		// Large enough!			{				inBlock->mLength += inAmount;		// Enlarge our block, the logical length stays the same.				mWastedBlocks.erase( vIterator );	// Kill old block.				mFileChanged = true;				return;	// Finished, success!			}		}	}		/* If we get here, there was no appropriate wasted block after ours. We need		to move this block to the end of the file and enlarge it there: */	vTheBlock = MoveBlockToEnd( inBlock );	// Sets changed flag.	vTheBlock->mLength += inAmount;		// Enlarge block.	SetLength( GetLength() +inAmount );	// Enlarge file.		mFileEnd += inAmount;	// Make sure block file's end is now after our block.}/* --------------------------------------------------------------------------------	MoveBlockToEnd:		Change this block so its data is directly at the end of the file.			TAKES:		inBlock -				The block to move.		GIVES:		XBlockEntry* -	A pointer to the moved block's block entry (can be								different from inBlock).								REVISIONS:		1999-06-23	UK		Created.   ----------------------------------------------------------------------------- */XBlockEntry*	XBlockFile::MoveBlockToEnd( XBlockEntry* inBlock ){	XBlockWastedSpace		vUnusedSpace;	XBlockOffset			vNewStart;		// Get end of file to write our new block to:	vNewStart = CalculateFileEnd();		// How lucky we are that the following works on the same file, too:	CopyBetweenFiles( mFile, mFile, inBlock->mOffset, vNewStart,						inBlock->mLogLength );		// Make sure we remember the old location as being wasted:	vUnusedSpace.mOffset = inBlock->mOffset;	vUnusedSpace.mLength = inBlock->mLength;	mWastedBlocks.insert( XWastedListItem(vUnusedSpace.mLength,vUnusedSpace) );		// Change old entry to point at new location:	inBlock->mOffset = vNewStart;	inBlock->mLength = inBlock->mLogLength;		// Block is this short now.		mFileEnd += inBlock->mLength;	// Make sure file ends after this block, which is now last.		mFileChanged = true;		return inBlock;}/* --------------------------------------------------------------------------------	StreamFromBlock:		Read some data from an on-disk block. The block *must not* be loaded into		RAM or it'll generate an exception.		TAKES:		inID -				ID of the block to get.		ioData -			Pointer to storage for data to read.		inLength -			Length of data to be read in bytes.		inWritePosition -	Offset into block where we are to get the data.		GIVES:		ioData -			The data read is written to this pointer.		REVISIONS:		MM-02-05	UK	Moved actual code to StreamFromBlockEntry.		1999-06-23	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockFile::StreamFromBlock( XBlockID inID,									void* ioData, XBlockOffset inLength,									XBlockOffset inWritePosition ){	XBlockEntry*		vTheBlock;		vTheBlock = GetBlockEntry( inID );	if( !vTheBlock )		throw InternalError( __FILE__, "StreamFromBlock", "Couldn't find specified block." );		StreamFromBlockEntry( vTheBlock, ioData, inLength, inWritePosition );}/* --------------------------------------------------------------------------------	StreamFromBlockEntry:		Read some data from an on-disk block.		TAKES:		vTheBlock -			Block entry of the block to read from.		ioData -			Pointer to storage for data to read.		inLength -			Length of data to be read in bytes.		inWritePosition -	Offset into block where we are to get the data.		GIVES:		ioData -			The data read is written to this pointer.		REVISIONS:		MM-02-05	UK		Changed to take block entry instead of ID. Added							support for RAM-resident blocks.		1999-06-23	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockFile::StreamFromBlockEntry( XBlockEntry* vTheBlock,											void* ioData, XBlockOffset inLength,											XBlockOffset inWritePosition ){	if( (vTheBlock->mFlags & BLOCK_DIRTY) == BLOCK_DIRTY		|| (vTheBlock->mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY )	// Block in RAM? Just copy to pointer.	{		if( inWritePosition > vTheBlock->mPointerLength )	// Mark out of range?			throw InternalError( __FILE__, "StreamFromBlockEntry", "Block data is too short to read from this offset." );				if( vTheBlock->mPointerLength < (inWritePosition +inLength) )	// User trying to read too much!!!			throw InternalError( __FILE__, "StreamFromBlockEntry", "Tried to read past logical end of block data." );				memmove( ioData, ((char*) ((long)vTheBlock->mPointer) +inWritePosition), inLength );	}	else	{		if( inWritePosition > vTheBlock->mLength )	// Mark out of range?			throw InternalError( __FILE__, "StreamFromBlockEntry", "Block is too short to read from this offset." );				if( vTheBlock->mLogLength < (inWritePosition +inLength) )	// User trying to read too much!!!			throw InternalError( __FILE__, "StreamFromBlockEntry", "Tried to read past logical end of block." );				SetOffset( vTheBlock->mOffset +inWritePosition );		Read( ioData, inLength );	}}/* --------------------------------------------------------------------------------	DumpMap:		Print the block map in readable format to the console. This also dumps		the maps of blocks that have sub blocks.				Used for debugging only.			TAKES:		inMap		-	The map to dump. May be a sub map.		inNestLevel	-	Number of tabs to write before each dumped entry. This						should start out with 0 (zero) and is added to each time						this function calls itself recursively to output a sub						map.		GIVES:		-								REVISIONS:		MM-02-06	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockFile::DumpMap( XBlockMap &inMap, unsigned long inNestLevel ){	for( XBlockMapIterator iterator = inMap.begin(); iterator != inMap.end(); ++iterator )	{		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "ID: " << iterator->second.mId << endl;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Offset: " << iterator->second.mOffset << endl;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Length: " << iterator->second.mLogLength << "(" << iterator->second.mLength << ")" << endl;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Pointer: " << (long) iterator->second.mPointer << endl;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Ptr Length: " << iterator->second.mPointerLength << endl;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Dirty: " << ((int)(iterator->second.mFlags & BLOCK_DIRTY) == BLOCK_DIRTY) << endl;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Not yet saved: " << ((int)(iterator->second.mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY) << endl;		bool		hasMap;		hasMap = (iterator->second.mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB;		for( long x = inNestLevel; x > 0; x-- )			std::cout << "\t";		std::cout << "Map: " << hasMap << endl;		if( hasMap )		{			if( iterator->second.mSubBlocks != NULL )				DumpMap( (*(XBlockMap*)iterator->second.mSubBlocks), inNestLevel +1 );			else			{				for( long x = inNestLevel; x >= 0; x-- )	// <= since it should indent just like map list.					std::cout << "\t";				std::cout << "<Map not yet loaded>" << endl;			}		}				std::cout << endl;	// Make sure we have empty line between entries.	}}/* --------------------------------------------------------------------------------	DumpWastedList:		Write the contents of the list of wasted blocks to the console.			REVISIONS:		MM-02-17	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockFile::DumpWastedList(){	std:cout << "Wasted blocks:" << endl;		for( XWastedIterator iterator = mWastedBlocks.begin(); iterator != mWastedBlocks.end(); ++iterator )	{		std::cout << "Offset: " << iterator->second.mOffset << endl;		std::cout << "Length: " << iterator->second.mLength << endl << endl;	// Empty line between entries.	}		std::cout << "Wasted blocks that won't be overwritten yet:" << endl;	for( XWastedIterator iterator = mNewlyWastedBlocks.begin(); iterator != mNewlyWastedBlocks.end(); ++iterator )	{		std::cout << "Offset: " << iterator->second.mOffset << endl;		std::cout << "Length: " << iterator->second.mLength << endl << endl;	// Empty line between entries.	}}/* --------------------------------------------------------------------------------	StreamToBlock:		Write some data to an on-disk block. The block *must not* be loaded into		RAM or it'll generate an exception.			TAKES:		inID -				ID of the block to get.		inData -			Pointer to data to be written.		inLength -			Length of data to be written in bytes.		inWritePosition -	Offset into block where we are to write the data.		GIVES:		-								REVISIONS:		MM-02-05	UK	Moved actual code to StreamToBlockEntry.		1999-06-24	UK	Fixed bug that caused block to become smaller when it						wasn't enlarged by streaming.		1999-06-23	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockFile::StreamToBlock( XBlockID inID,									void* inData, XBlockOffset inLength,									XBlockOffset inWritePosition ){	XBlockEntry*		vTheBlock;		vTheBlock = GetBlockEntry( inID );	if( !vTheBlock )		throw InternalError( __FILE__, "StreamToBlock", "Couldn't find requested block." );		StreamToBlockEntry( vTheBlock, inData, inLength, inWritePosition );}/* --------------------------------------------------------------------------------	StreamToBlockEntry:		Write some data to an on-disk block. The block *must not* be loaded into		RAM or it'll generate an exception.			TAKES:		inID -				ID of the block to get.		inData -			Pointer to data to be written.		inLength -			Length of data to be written in bytes.		inWritePosition -	Offset into block where we are to write the data.		GIVES:		-								REVISIONS:		MM-02-05	UK	Changed to take block entry instead of ID.		1999-06-24	UK	Fixed bug that caused block to become smaller when it						wasn't enlarged by streaming.		1999-06-23	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockFile::StreamToBlockEntry( XBlockEntry *vTheBlock,										void* inData, XBlockOffset inLength,										XBlockOffset inWritePosition ){	XBlockOffset		vMissingSize,						vAdditionalLength;		if( (vTheBlock->mFlags & BLOCK_DIRTY) == BLOCK_DIRTY		|| (vTheBlock->mFlags & BLOCK_RAM_ONLY) == BLOCK_RAM_ONLY )		// RAM-resident block?	{		if( inWritePosition > vTheBlock->mPointerLength )	// Mark out of range?			throw InternalError( __FILE__, "StreamToBlockEntry", "Attempted to write past end of block data." );				if( vTheBlock->mPointerLength < (inWritePosition +inLength) )	// Need this check since we're using unsigned numbers!			vMissingSize = -(vTheBlock->mPointerLength -inWritePosition -inLength);		else			vMissingSize = 0;				if( vMissingSize >= 0 )	// Need to enlarge block?		{			// Enlarge block to also hold missing size +AUTO_FLUFF_AMOUNT:			ResizeBlockEntry( vTheBlock, (((vTheBlock->mPointerLength +vMissingSize) / AUTO_FLUFF_AMOUNT) +1) * AUTO_FLUFF_AMOUNT );		}				memmove( ((char*)((long)vTheBlock->mPointer) +inWritePosition), inData, inLength );	}	else	// Disk-only block?	{		if( inWritePosition > vTheBlock->mLength )	// Mark out of range?			throw InternalError( __FILE__, "StreamToBlockEntry", "Attempted to write past end of block." );				if( vTheBlock->mLength < (inWritePosition +inLength) )	// Need this check since we're using unsigned numbers!			vMissingSize = -(vTheBlock->mLength -inWritePosition -inLength);		else			vMissingSize = 0;				if( vMissingSize >= 0 )	// Need to enlarge block?		{			// Enlarge block to also hold missing size +AUTO_FLUFF_AMOUNT:			FluffBlock( vTheBlock, ((vMissingSize / AUTO_FLUFF_AMOUNT) +1) * AUTO_FLUFF_AMOUNT );						// FIX ME! Check whether block entry can really change in response to the above call. Would be BAD!		}				SetOffset( vTheBlock->mOffset +inWritePosition );		Write( inData, inLength );				if( vTheBlock->mLogLength < (inWritePosition +inLength) )	// Block grew in result to this write?			vAdditionalLength = -(vTheBlock->mLogLength -inWritePosition -inLength);	// Remember how much.		else			vAdditionalLength = 0;	// Didn't grow.				vTheBlock->mLogLength += vAdditionalLength;	}		mFileChanged = true;}/* --------------------------------------------------------------------------------	GetSubBlockMap:		Read a block's map into a RAM structure and return that.			TAKES:		inEntry		-	The block entry whose map we are to read.		GIVES:		XBlockMap*	-	Pointer to a new block map. Caller is responsible of						disposing of this.								REVISIONS:		2000-01-15	UK	Created.   ----------------------------------------------------------------------------- */XBlockMap*	XBlockFile::GetSubBlockMap( XBlockEntry* inEntry ){	XBlockMap*		vTheMap = NULL;		if( (inEntry->mFlags & BLOCK_HAS_SUB) == BLOCK_HAS_SUB )	{		vTheMap = new XBlockMap;				SetOffset( inEntry->mOffset );		if( inEntry->mLength >= sizeof(XBlockOffset) )	// Only load map if block isn't empty.			LoadBlocksIntoList( (*vTheMap), inEntry );	// Load map and make all entries sub blocks of this entry.	}	else		throw InternalError( __FILE__, "GetSubBlockMap", "There are no sub blocks." );		return vTheMap;}/* --------------------------------------------------------------------------------	AddSubBlock:		Add a new sub block to the entry inEntry. Any existing sub blocks of this		entry with same ID will be replaced.			TAKES:		inEntry		-	The block entry to which we'll add a sub block.		inID		-	ID for the new block.		inData		-	A pointer to data to write to this block.		inLength	-	The length of the data to write from inData.								REVISIONS:		MM-02-05	UK	Finished.		MM-01-15	UK	Created.   ----------------------------------------------------------------------------- */XBlockEntry*	XBlockFile::AddSubBlock( XBlockEntry* inEntry, XBlockID inID,											void* inData, XBlockOffset inLength ){	XBlockOffset		vCount = 0,	// Means empty map.						vNewSize;	XBlockEntry*		vNewEntry = NULL;		if( (inEntry->mFlags & BLOCK_HAS_SUB) != BLOCK_HAS_SUB )	// No map yet?	{		// Make block size of empty block map:		vNewSize = sizeof(XBlockOffset);	// Size of count field, we'll add to this later and resize in one sweep.		inEntry->mSubBlocks = new XBlockMap();				inEntry->mFlags |= BLOCK_HAS_SUB | BLOCK_DIRTY;	// Set flag to indicate this is map and we just changed it.	}	else	// This is already a map:	{		// Make sure block map is loaded:		if( inEntry->mSubBlocks == NULL )			inEntry->mSubBlocks = GetSubBlockMap( inEntry );				/* Get # of entries so we can detect when a block has been added and we didn't			replace. This also fixes the size in case the block was empty. */		vCount = ((XBlockMap*)inEntry->mSubBlocks)->size();		if( vCount > 0 )			vNewSize = inEntry->GetLength();		else	// No blocks yet, but flag set??? Oh my!			vNewSize = sizeof(XBlockOffset);	// Just to be safe, we make sure this is forced to be correct size.				inEntry->mFlags |= BLOCK_DIRTY;	// Make sure we remember map changed!	}		// Actually create sub-block:	vNewEntry = AddBlockToMap( (*((XBlockMap*)inEntry->mSubBlocks)), inID, inData, inLength );	vNewEntry->mSuperEntry = inEntry;	// Make sure this entry knows what block it belongs to.		// If block count changed (i.e. we didn't replace an existing block) resize this block:	if( vCount != ((XBlockMap*)inEntry->mSubBlocks)->size() )		ResizeBlockEntry( inEntry, vNewSize +DISK_BLOCK_ENTRY_SIZE );	else if( inEntry->GetLength() != vNewSize )	// In case the block used to have data.		ResizeBlockEntry( inEntry, vNewSize );		// Now make the whole branch dirty:	XBlockEntry*	vCurrEntry = vNewEntry;	while( vCurrEntry->mSuperEntry )	{		vCurrEntry = vCurrEntry->mSuperEntry;		vCurrEntry->mFlags |= BLOCK_DIRTY;	}		return vNewEntry;}#pragma mark -#pragma mark [XBlockEntry]/* --------------------------------------------------------------------------------	е CONSTRUCTOR:		Initialize fields in this block.										REVISIONS:		1999-07-23	UK	Created.   ----------------------------------------------------------------------------- */XBlockEntry::XBlockEntry( XBlockFile* inFile, XBlockEntry* superEntry ){	mId = 0;	mOffset = 0;	mLength = 0;	mLogLength = 0;	mPointer = NULL;	mPointerLength = 0;	mFlags = 0;	mSubBlocks = NULL;	mSuperEntry = superEntry;	mFile = inFile;}/* --------------------------------------------------------------------------------	е COPY CONSTRUCTOR:		Initialize fields in this block based on data from another block.										REVISIONS:		1999-10-30	UK	Created.   ----------------------------------------------------------------------------- */XBlockEntry::XBlockEntry( XBlockEntry& inEntry ){	ModelMeAfter( inEntry );}/* --------------------------------------------------------------------------------	е DESTRUCTOR:		Initialize fields in this block.										REVISIONS:		1999-07-23	UK	Created.   ----------------------------------------------------------------------------- */XBlockEntry::~XBlockEntry(){	UnloadData();		if( mSubBlocks )		delete ((XBlockMap*)mSubBlocks);}/* --------------------------------------------------------------------------------	operator=:		Assignment operator overload that makes sure we copy pointers' contents.			TAKES:		inBlock -	The block assigned to this.		GIVES:		-								REVISIONS:		1999-10-30	UK	Created.   ----------------------------------------------------------------------------- */XBlockEntry& XBlockEntry::operator=( XBlockEntry& inEntry ){	if( mSubBlocks )		delete ((XBlockMap*) mSubBlocks);	mSubBlocks = NULL;		UnloadData();	ModelMeAfter( inEntry );		return (*this);}/* --------------------------------------------------------------------------------	ModelMeAfter:		Initialize fields in this block based on data from another block.		Called by operator=. This smashes any existing pointers and doesn't		dispose of their data.		TAKES:		inEntry	-	pointer to block we are to mimic.										REVISIONS:		1999-10-30	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockEntry::ModelMeAfter( XBlockEntry& inEntry ){	mId = inEntry.mId;	mOffset = inEntry.mOffset;	mLength = inEntry.mLength;	mLogLength = inEntry.mLogLength;	mFlags = inEntry.mFlags;	mSuperEntry = inEntry.mSuperEntry;	mFile = inEntry.mFile;	if( inEntry.mSubBlocks )		mSubBlocks = new XBlockMap( (*(XBlockMap*) inEntry.mSubBlocks) );	else		mSubBlocks = NULL;	if( inEntry.mPointer != NULL && inEntry.mPointerLength != 0 )	{		mPointer = malloc( sizeof(inEntry.mPointerLength) );		if( mPointer )		{			memcpy( mPointer, inEntry.mPointer, inEntry.mPointerLength );	// ANSI is backwards!			mPointerLength = inEntry.mPointerLength;		}		else			throw MemoryError( __FILE__, "ModelMeAfter", "Couldn't copy data pointer." );	}	else	{		mPointer = NULL;		mPointerLength = 0;	}}/* --------------------------------------------------------------------------------	SwapData:		Sets this block's data pointers to those of another block and its data		pointers to ours, thus effectively swapping the data in RAM and on DISK		both blocks point to.			TAKES:		ioBlock -	The block whose data will be swapped with this one.		GIVES:		-								REVISIONS:		1999-07-23	UK	Created.   ----------------------------------------------------------------------------- */void	XBlockEntry::SwapData( XBlockEntry& ioBlock ){	XBlockOffset	vOffset,					vLength,					vLogLength,					vPointerLength;	void*			vPointer;		vPointer = ioBlock.mPointer;	vOffset = ioBlock.mOffset;	vLength = ioBlock.mLength;	vLogLength = ioBlock.mLogLength;	vPointerLength = ioBlock.mPointerLength;		ioBlock.mPointer = mPointer;	ioBlock.mOffset = mOffset;	ioBlock.mLength = mLength;	ioBlock.mLogLength = mLogLength;	ioBlock.mPointerLength = mPointerLength;		mPointer = vPointer;	mOffset = vOffset;	mLength = vLength;	mLogLength = vLogLength;	mPointerLength = vPointerLength;}/* --------------------------------------------------------------------------------	GetBlockEntry:		Loop over all sub blocks and look for a block of specified ID to then		return its block entry.				inID	- The ID of the block you're looking for. This must be a positive					integer.								Returns NULL if there is no block of specified ID.		REVISIONS:		1999-01-16	UK		Created.   ----------------------------------------------------------------------------- */XBlockEntry*	XBlockEntry::GetBlockEntry( XBlockID inID ){	XBlockMapIterator		vIterator;		if( mSubBlocks == NULL )	// Map not yet loaded?		mSubBlocks = mFile->GetSubBlockMap( this );	// Load it now.		vIterator = ((XBlockMap*) mSubBlocks)->find( inID );	if( vIterator != ((XBlockMap*) mSubBlocks)->end() )	// Actually found something.		return &vIterator->second;	else		return NULL;}/* --------------------------------------------------------------------------------	WriteToFile:		Writes this block entry's fields that are relevant for on-disk storage		to the file passed in. Does *not* write down the block's data or any		sub blocks. This starts writing at the passed file object's current		offset and moves it past the data written.		TAKES:		destFile	-	The file to write to and whose offset is set to the						position at which you want to have this entry written.		GIVES:		-		REVISIONS:		MM-03-01	UK		Created.   ----------------------------------------------------------------------------- */void	XBlockEntry::WriteToFile( XEndianFile& destFile ){	destFile.WriteLong( mId );	destFile.WriteLong( mOffset );	//destFile.WriteLong( mLength );	// When saving this is forced same as mLogLength by wasting excess data.	destFile.WriteLong( mLogLength );	//destFile.WriteLong( mSubMapLength );	// Obsolete.	destFile.WriteChar( mFlags );}/* --------------------------------------------------------------------------------	GetLength:		Returns the size of this block. If the block is in RAM, it returns the		size of the RAM data, if it is not, it returns the on-disk size.		REVISIONS:		MM-02-05	UK		Created.   ----------------------------------------------------------------------------- */size_t	XBlockEntry::GetLength(){	if( mPointer )		return mPointerLength;	else		return mLogLength;}