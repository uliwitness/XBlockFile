/*	***************************************************************************	PROJECT:	Joker		FILE:		XRedBlackTree.cpp		PURPOSE:	Implementation of a red/black tree in a C++ class.		COPYRIGHT:	(C) Copyright 1999 by Brian Yennie, all rights reserved.				Adapted to a C++ class by M. Uli Kusterer.					REACH US AT:				E-MAIL:		Yennie@aol.com							witness@weblayout.com		REVISIONS:		1999-10-17	UK		Finished iterators, recursive list and size() func.		1999-08-14	UK		Created based on Brian's C code.					************************************************************************ */#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */#include "XRedBlackTree.h"#include <time.h>#pragma mark [Globals]/* --------------------------------------------------------------------------------	Static Member Variables and Globals:   ----------------------------------------------------------------------------- */// Put here.#pragma mark [Implementation]/* --------------------------------------------------------------------------------	¥ CONSTRUCTOR:			REVISIONS:		1999-10-10	UK		Moved here from header.   ----------------------------------------------------------------------------- */template< class keyType, class recType >XRedBlackTree< keyType, recType >::XRedBlackTree(){	rootNode = NULL_NODE;}/* --------------------------------------------------------------------------------	¥ DESTRUCTOR:		Free all memory used by our tree.			REVISIONS:		1999-08-24	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >XRedBlackTree< keyType, recType >::~XRedBlackTree(){	killAll();}/* --------------------------------------------------------------------------------	rotateLeft:		Rotate a node to left.		TAKES:		x -		node to rotate.		GIVES:		-		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::rotateLeft(nodeType *x){    nodeType *y = x->right;    /* establish x->right link */    x->right = y->left;    if (y->left != NULL_NODE) y->left->parent = x;    /* establish y->parent link */    if (y != NULL_NODE) y->parent = x->parent;    if (x->parent) {        if (x == x->parent->left)            x->parent->left = y;        else            x->parent->right = y;    } else {        rootNode = y;    }    /* link x and y */    y->left = x;    if (x != NULL_NODE) x->parent = y;}/* --------------------------------------------------------------------------------	rotateRight:		Rotate a node to right.		TAKES:		x -		node to rotate.		GIVES:		-		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::rotateRight(nodeType *x){    nodeType *y = x->left;    /* establish x->left link */    x->left = y->right;    if (y->right != NULL_NODE) y->right->parent = x;    /* establish y->parent link */    if (y != NULL_NODE) y->parent = x->parent;    if (x->parent) {        if (x == x->parent->right)            x->parent->right = y;        else            x->parent->left = y;    } else {        rootNode = y;    }    /* link x and y */    y->right = x;    if (x != NULL_NODE) x->parent = y;}/* --------------------------------------------------------------------------------	insertFixup:		maintain red-black tree balance after inserting node x.		TAKES:		x -		node to insert.		GIVES:		-		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::insertFixup(nodeType *x){    /* check Red-Black properties */    while (x != rootNode && x->parent->color == RED) {        /* we have a violation */        if (x->parent == x->parent->parent->left) {            nodeType *y = x->parent->parent->right;            if (y->color == RED) {                /* uncle is RED */                x->parent->color = BLACK;                y->color = BLACK;                x->parent->parent->color = RED;                x = x->parent->parent;            } else {                /* uncle is BLACK */                if (x == x->parent->right) {                    /* make x a left child */                    x = x->parent;                    rotateLeft(x);                }                /* recolor and rotate */                x->parent->color = BLACK;                x->parent->parent->color = RED;                rotateRight(x->parent->parent);            }        } else {            /* mirror image of above code */            nodeType *y = x->parent->parent->left;            if (y->color == RED) {                /* uncle is RED */                x->parent->color = BLACK;                y->color = BLACK;                x->parent->parent->color = RED;                x = x->parent->parent;            } else {                /* uncle is BLACK */                if (x == x->parent->left) {                    x = x->parent;                    rotateRight(x);                }                x->parent->color = BLACK;                x->parent->parent->color = RED;                rotateLeft(x->parent->parent);            }        }    }    rootNode->color = BLACK;}/* --------------------------------------------------------------------------------	insert:		allocate node for data and insert in tree.		TAKES:		x -		node to rotate.		GIVES:		-		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >statusEnum	XRedBlackTree< keyType, recType >::insert(keyType key, recType *rec){    nodeType	*current,    								*parent,    								*x;    /* find future parent */    current = rootNode;    parent = 0;    while (current != NULL_NODE) {        if (compEQ(key, current->key)) {        	/* setup new node */        	        	/*    		if ((x = malloc (sizeof(*x))) == 0)        		return STATUS_MEM_EXHAUSTED;    		x->parent = current->parent;    		x->left = current->left;    		x->right = current->right;    		x->color = current->color;    		x->key = key;    		x->rec = *rec;    		x->next = current;    		if (parent) {    			if compLTEQU(key, current->parent->key) current->parent->left = x;    			else current->parent->right = x;    		}    		if (current == rootNode) rootNode = x;            return STATUS_OK;            */        }        parent = current;        current = compLTEQU(key, current->key) ?            current->left : current->right;    }    /* setup new node */    if ((x = (nodeType*) malloc (sizeof(*x))) == 0)        return STATUS_MEM_EXHAUSTED;    x->parent = parent;    x->left = NULL_NODE;    x->right = NULL_NODE;    x->color = RED;    x->key = key;    x->rec = *rec;    //x->next = 0L;    /* insert node in tree */    if(parent) {        if(compLTEQU(key, parent->key))            parent->left = x;        else            parent->right = x;    } else {        rootNode = x;    }    insertFixup(x);    return STATUS_OK;}/* --------------------------------------------------------------------------------	deleteFixup:		maintain Red-Black tree balance after deleting node x.		TAKES:		x -		node to rotate.		GIVES:		-		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::deleteFixup(nodeType *x){    while (x != rootNode && x->color == BLACK) {        if (x == x->parent->left) {            nodeType *w = x->parent->right;            if (w->color == RED) {                w->color = BLACK;                x->parent->color = RED;                rotateLeft (x->parent);                w = x->parent->right;            }            if (w->left->color == BLACK && w->right->color == BLACK) {                w->color = RED;                x = x->parent;            } else {                if (w->right->color == BLACK) {                    w->left->color = BLACK;                    w->color = RED;                    rotateRight (w);                    w = x->parent->right;                }                w->color = x->parent->color;                x->parent->color = BLACK;                w->right->color = BLACK;                rotateLeft (x->parent);                x = rootNode;            }        } else {            nodeType *w = x->parent->left;            if (w->color == RED) {                w->color = BLACK;                x->parent->color = RED;                rotateRight (x->parent);                w = x->parent->left;            }            if (w->right->color == BLACK && w->left->color == BLACK) {                w->color = RED;                x = x->parent;            } else {                if (w->left->color == BLACK) {                    w->right->color = BLACK;                    w->color = RED;                    rotateLeft (w);                    w = x->parent->left;                }                w->color = x->parent->color;                x->parent->color = BLACK;                w->left->color = BLACK;                rotateRight (x->parent);                x = rootNode;            }        }    }    x->color = BLACK;}/* --------------------------------------------------------------------------------	deleteNode:		delete node with specified key.		TAKES:		key -		key of node you want to delete.		GIVES:		-		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >statusEnum	XRedBlackTree< keyType, recType >::deleteNode(keyType key){    nodeType		*x,    									*y,    									*z,    									*parent;    //  delete node z from tree    /* find node in tree */    z = rootNode;    parent = 0;        while( z != NULL_NODE )    {        if( compEQ(key, z->key) )             break;        else        {        	parent = z;            z = compLTEQU(key, z->key) ? z->left : z->right;        }    }        if( z == NULL_NODE )    	throw InternalError( __FILE__, "XRedBlackTree::deleteNode", "Couldn't find node." );	    return killNode( z );}/* --------------------------------------------------------------------------------	killNode:		Delete the node specified by pointer from the tree. This does not delete		the node's sub nodes but rather makes sure they are sorted into the tree.		TAKES:		z			-	The node you want to delete.		GIVES:		statusEnum	-	Error codes.		REVISIONS:		1999-10-23	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >statusEnum	XRedBlackTree< keyType, recType >::killNode( nodeType* z ){	nodeType		*x,				*y;		if( z->left == NULL_NODE || z->right == NULL_NODE )    {        /* y has a NULL_NODE node as a child */        y = z;    }    else    {        /* find tree successor with a NULL_NODE node as a child */        y = z->right;                while( y->left != NULL_NODE )        	y = y->left;    }    /* x is y's only child */    if (y->left != NULL_NODE)        x = y->left;    else        x = y->right;    /* remove y from the parent chain */    x->parent = y->parent;    if( y->parent )    {		if( y == y->parent->left )			y->parent->left = x;		else			y->parent->right = x;	}	else		rootNode = x;    if (y != z)    {        z->key = y->key;        z->rec = y->rec;    }    if( y->color == BLACK )        deleteFixup( x );    free( y );        return STATUS_OK;}/* --------------------------------------------------------------------------------	getNext:		Get next node in tree after the one specified.		TAKES:		current		-	The node whose successor we are to get, or NULL_NODE to						get the first node.		GIVES:		current		-	The node following the one specified on input, or						NULL_NODE if there are no more nodes.		NOTE:		Iterating a tree this way is kinda hairy. For this reason we keep				some data in each node that tells us whether we already visited				this node. There are three states: NODE_ITSELF_VISITED means we				are returning this node right now, and this is set whenever a node				is returned.				LEFT_CHILD_VISITED means this node has been visited and it has two				children of which we are now returning the left one.				ALL_CHILDS_VISITED means this node has been visited and it has one				unvisited child which we are now returning.							If a node with ALL_CHILDS_VISITED is passed in, this means we are				completely done with this node. So we loop uptree again (using the				"parent" field) until we encounter a node that is				LEFT_CHILD_VISITED (it can't be NODE_ITSELF_VISITED since it's our				parent and we do a left-first search) or until we are at the root				and the root also has ALL_CHILDS_VISITED set, in which case we				return NULL.			WARNING:	If you call getNext() in a loop, be sure to check the node pointer				you pass in against the NULL node and exit if that's the case, or				you could enter an endless loop.		REVISIONS:		1999-10-04	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::getNext( nodeType **current ){	if( (*current) == NULL_NODE )	{		(*current) = rootNode;		if( (**current).left == NULL_NODE )		{			if( (**current).right == NULL_NODE )				(**current).beenThere = ALL_CHILDS_VISITED;			else				(**current).beenThere = LEFT_CHILD_VISITED;		}		else			(**current).beenThere = NODE_ITSELF_VISITED;		return;	}		switch( (**current).beenThere )	{		case NODE_ITSELF_VISITED:			// Go to our left child:			if( (**current).right != NULL_NODE )	// Have a right child that also needs to be walked?				(**current).beenThere = LEFT_CHILD_VISITED;			else	// This is the only child?				(**current).beenThere = ALL_CHILDS_VISITED;	// We're done.			if( (**current).left != NULL_NODE )			{				(*current) = (**current).left;				// Clear left child's flag:				(**current).beenThere = NODE_ITSELF_VISITED;				break;			}			// Else drop through!!!				case LEFT_CHILD_VISITED:			// Go to our right child:			(**current).beenThere = ALL_CHILDS_VISITED;			if( (**current).right != NULL_NODE )			{				(*current) = (**current).right;				// Clear right child's flag:				(**current).beenThere = NODE_ITSELF_VISITED;				break;			}			// Else drop through!				case ALL_CHILDS_VISITED:			// Go to our boss:				// Note that for some strange reason this NULL_NODE nonsense isn't used for parents.			while( (*current) != NULL_NODE && (**current).beenThere == ALL_CHILDS_VISITED )				(*current) = (**current).parent;						if( (*current) != NULL_NODE )	// We're about to return a node:			{				if( (**current).beenThere == NODE_ITSELF_VISITED )				{					if( (**current).right == NULL_NODE )						(**current).beenThere = ALL_CHILDS_VISITED;					else						(**current).beenThere = LEFT_CHILD_VISITED;										(*current) = (**current).left;					(**current).beenThere = NODE_ITSELF_VISITED;				}				else if( (**current).beenThere == LEFT_CHILD_VISITED )				{					(**current).beenThere = ALL_CHILDS_VISITED;										(*current) = (**current).right;					(**current).beenThere = NODE_ITSELF_VISITED;				}			}			break;	}}/* --------------------------------------------------------------------------------	doForEach:		Call the procedure passed on every node in our tree.		TAKES:		proc	-	the function to call This hast to be declared as					void name( keyType, recType ).		GIVES:		-		REVISIONS:		1999-10-08	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::doForEach( doForEachProcType* proc ){	if( rootNode != NULL_NODE )		callProcForNode( rootNode, proc );}/* --------------------------------------------------------------------------------	callProcForNode:		This is called recursively by doForEach to walk the tree.		TAKES:		proc	-	the function to call This has to be declared as					void name( keyType, recType& ).		GIVES:		-		REVISIONS:		1999-10-08	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::callProcForNode( nodeType* currNode, doForEachProcType* proc ){	(*proc)( currNode->key, currNode->rec );			if( currNode->left != NULL_NODE )		callProcForNode( currNode->left, proc );		if( currNode->right != NULL_NODE )		callProcForNode( currNode->right, proc );}/* --------------------------------------------------------------------------------	find:		find record with exact key match.		TAKES:		key -		key of node you want to find.		rec -		pointer to a variable to hold resulting record.		GIVES:		rec -		record fetched from the node.		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >statusEnum	XRedBlackTree< keyType, recType >::find(keyType key, recType *rec){    nodeType*		current = rootNode;        while(current != NULL_NODE) {        if(compEQ(key, current->key)) {            *rec = current->rec;            return STATUS_OK;        } else {            current = compLTEQU (key, current->key) ?                current->left : current->right;        }    }        return STATUS_KEY_NOT_FOUND;}/* --------------------------------------------------------------------------------	findClosest:		Find record with key larger or same as key passed. This tries to fetch		the node with the least difference in keys (i.e. the lowest key eligible).		TAKES:		key -		key of node you want to find.		rec -		pointer to a variable to hold resulting record.		GIVES:		rec -		record fetched from the node.		REVISIONS:		1999-08-14	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >statusEnum	XRedBlackTree< keyType, recType >::findClosest(keyType *key, recType *rec){	nodeType*		temp;	nodeType*		current = rootNode;	    while(current != NULL_NODE) {    	/* if we find an exact match, return it */        if(compEQ(*key, current->key)) {            *rec = current->rec;            *key = current->key;            return STATUS_OK;        } else {            if (compLT(*key, current->key)) {            	/* current key is valid, return it if we can't get any smaller */            	temp = current->left;            	if (temp == NULL_NODE) {            		*rec = current->rec;            		*key = current->key;            		return STATUS_OK;            	}            	            	/* if left is too small, is any node to the right large enough? */            	if (compLT(temp->key, *key)) {            		/* keep going right until we find a large enough node */       				while (temp->right != NULL_NODE) {            			if (compLTEQU(*key, temp->right->key)) {            				current = temp->right;            				break;            			}            			temp = temp->right;            		}            		if (temp->right == NULL_NODE) {            			/* no nodes to the right of the left are large enough, so return current node */            			*rec = current->rec;            			*key = current->key;            			return STATUS_OK;            		}            	} else {            		/* if left is still larger or equal, go there */            		current = temp;            	}            } else {            	/* if we got here then we need to get larger */            	current = current->right;            }        }    }    return STATUS_KEY_TOO_LARGE;}/* --------------------------------------------------------------------------------	killAll:		Deletes all nodes starting at the specified one from this tree. Calls		itself recursively.		TAKES:		rec -		pointer to the first record to delete.		GIVES:		-		REVISIONS:		1999-08-24	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::killAll( nodeType *rec ){	if( rec == NULL_NODE )		return;		// First kill our subnodes:	if( rec->left != NULL_NODE )		killAll( rec->left );		if( rec->right != NULL_NODE )		killAll( rec->right );		if( rec->parent != NULL_NODE )	// We're not root.	{		if( rec->parent->left == rec )			rec->parent->left = NULL_NODE;		else			rec->parent->right = NULL_NODE;	}		free( rec );}/* --------------------------------------------------------------------------------	killAll:		Deletes all nodes.		REVISIONS:		1999-09-26	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >void	XRedBlackTree< keyType, recType >::killAll(){	killAll( rootNode );}/* --------------------------------------------------------------------------------	size:		Return number of items. This is rather costly. We iterate once over the		tree and add up.		REVISIONS:		1999-10-17	UK		Created.   ----------------------------------------------------------------------------- */template< class keyType, class recType >size_t	XRedBlackTree< keyType, recType >::size(){	nodeType*		vNode = NULL_NODE;	size_t			vCount = 0;		do	{		getNext( &vNode );				if( vNode != NULL_NODE )			vCount++;	}	while( vNode != NULL_NODE );		return vCount;}