<HTML><!--This file created 20.02.2000 17:22 Uhr by Claris Home Page version 3.0 30 Day Trial--><HEAD>   <TITLE>XBlockFile</TITLE>   <META NAME=GENERATOR CONTENT="Claris Home Page 3.0 30 Day Trial">   <X-CLARIS-WINDOW TOP=42 BOTTOM=613 LEFT=4 RIGHT=534>   <X-CLARIS-TAGVIEW MODE=minimal></HEAD><BODY BGCOLOR="#FFFFFF"><H1><CENTER>XBlockFile Documentation</CENTER></H1><P>This is the programmers' documentation of the file format used bythe XBlockFile class that implements a file consisting of anarbitrary number of chunks of data (called "blocks") that are indexedusing an ID. Each block may have an arbitrary number of sub-blocks,which in turn may have an arbitrary number of sub-blocks and soon.</P><P>XBlockFile transparently handles management of blocks, includingsupport for streaming from/to blocks, changing block sizes orperforming endian conversion. Furthermore, XBlockFile allowscompacting a block file to have it take up as little disk space aspossible by stripping no longer used blocks from a file. Note thatthis does not include compression.</P><P>The requirements for an XBlockFile implementation are:</P><OL>   <LI>Stability and data-safety. Ideally, no action performed on an   XBlockFile should result in the file becoming invalid under any   condition, including errors like a full disk.<BR>   &nbsp;</LI>      <LI>Speed. XBlockFile is guaranteed to perform well even with huge   numbers of blocks and file sizes of several megabytes.<BR>   &nbsp;</LI>      <LI>Low RAM footprint. XBlockFile will work with little memory. In   particular, no implementation may require the whole file to be   loaded into RAM, and it must support streaming of huge blocks   without loading that block into RAM.<BR>   &nbsp;</LI>      <LI>Limitless storage. Ideally, any XBlockFile implementation   should be limited only by available RAM and disk space when it   comes to creating large blocks and block files. There is no such   thing as a maximum number of blocks.<BR>   &nbsp;</LI>      <LI>Platform safety. Any XBlockFile implementation must be written   in a way that it can read/write binary exchangeable files written   on any platform, no matter whether big or little endian, RISC or   CISC CPU etc. As a compromise to allow for more speed, it may   generate files that contain a flag specifying the endian-mode, but   it must be able to transparently convert files with different   endian-modes than the native mode of the current platform.   Compacting must result in native-endian files, though.</LI></OL><CENTER><IMG SRC="XBFFileF.GIF" WIDTH=269 HEIGHT=416 ALIGN=bottom><P><IMG SRC="XBFBlock.GIF" WIDTH=228 HEIGHT=164 X-CLARIS-USEIMAGEWIDTH X-CLARIS-USEIMAGEHEIGHT ALIGN=bottom></P></CENTER><P>Physical Length is the actual amount of space occupied by theblock. Logical Length is the amount actually used for data in theblock. This is used during streaming, where you can increase thephysical size in advance so you don't have to continually move arounddata.</P><P>Every block may contain either block data, or it may be acontainer of other blocks. In this case, its data consists of a blockmap that has the same format as the file's block map except that itdoesn't contain a list of wasted blocks (as wasted blocks are allkept track of in the file's wasted list). Whether a block containsdata or a map is indicated by a block flag. The block only containsthe block map entries, it doesn't contain the actual data of its subblocks. These are stored at any arbitrary location in the file justlike the data of root-level blocks; that is, data of blocks andsub-blocks (and sub-sub-blocks etc.) are stored intermixed in afile.</P><CENTER><IMG SRC="XBFWaste.GIF" WIDTH=234 HEIGHT=81 ALIGN=bottom></CENTER><P>Length of wasted data is the physical block length, the logicallength is not important as all data is wasted, not just the logicaldata.</P></BODY></HTML>