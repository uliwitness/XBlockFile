/*	***************************************************************************	PROJECT:	Joker		FILE:		XRedBlackTree.h		PURPOSE:	Implementation of a red/black tree in a C++ class.			COPYRIGHT:	(C) Copyright 1999 by Bryan Yennie, all rights reserved.				Adapted to a C++ class by M. Uli Kusterer.					REACH US AT:				E-MAIL:		Yennie@aol.com							witness@weblayout.com		REVISIONS:		1999-08-14	UK		Created based on Brian's C code.					************************************************************************ */#ifndef XREDBLACKTREE_H#define XREDBLACKTREE_H#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */   #include <stdio.h>#include <stdlib.h>#include <string.h>#include <stdarg.h>#pragma mark [Class Declaration]/* --------------------------------------------------------------------------------	Macros/Constants:   ----------------------------------------------------------------------------- */// Comparison functions for keys:#define compLT(a,b) ((a) < (b))#define compLTEQU(a,b) ((a) <= (b))#define compEQ(a,b) ((a) == (b))// Type used to indicate leafs:#define NULL_NODE 		NULL#pragma mark [Class Declaration]/* --------------------------------------------------------------------------------	Class declaration:   ----------------------------------------------------------------------------- *///typedef long		keyType;//typedef long		recType;typedef enum{    STATUS_OK,    STATUS_MEM_EXHAUSTED,    STATUS_DUPLICATE_KEY,    STATUS_KEY_NOT_FOUND,    STATUS_KEY_TOO_LARGE} statusEnum;template< class keyType, class recType >class	XRedBlackTree{friend class XRBIterator;protected:	/* START INTERNAL STRUCTURES */	typedef enum { BLACK, RED } nodeColor;	/* Possible beenThere values. This is increased by 1 every time when iterating	so we encounter each one only once. */	typedef enum	{		NODE_ITSELF_VISITED = 0,		LEFT_CHILD_VISITED,		ALL_CHILDS_VISITED	} beenThereEnum;		/*	This is what a node looks like in this tree.	*/	struct nodeType	{		struct nodeType 	*left;		// Left child.		struct nodeType 	*right;		// Right child.		struct nodeType		*parent;	// Supernode.		nodeColor 			color;		// Color of this node (Red/Black).		keyType		 		key;		// This node's key (doesn't have to be unique).		recType		 		rec;		// The actual record associated with this node.		beenThereEnum		beenThere;	// Used for iterators.	};		typedef void doForEachProcType( keyType&, recType& );	// Pass a proc of this type to doForEach.		/*	Iterator class. You get an object of this type through the first() method	in XRedBlackTree. Simply use a prefix/postfix ++ on this to advance to	the next record. Use currRec or currKey to get the key/value of that	record.		The iterator's members *should* be in the .cpp file instead of here inside	the header, but I can't get the hang of properly declaring a subclass of	a template class as a template class and so I put them here. If you know	how to declare them, please move them to the .cpp file.	*/	template< class keyType, class recType >	class	XRBIteratorTemplate	{	friend class XRedBlackTree;	protected:		nodeType			*currentNode;	// This is the variable constantly updated by getNext().		bool				mStart;		// Did we run already?		bool				mEnd;		// Is this run finished?		XRedBlackTree		*mOwner;	// The tree we iterate on.			protected:		XRBIteratorTemplate( XRedBlackTree *rbt )			: currentNode(NULL_NODE), mStart(false), mEnd(false)		{			mOwner = rbt;		};	public:		recType&	operator++()		{			return( getNextRec() );		};		recType&	operator++( int )		{			return( getNextRec() );		};				recType&	getNextRec()	// Set mStart/mEnd and call getNext().		{			if( end() )				mEnd = false;						mOwner->getNext( &currentNode );			mStart = true;			if( currentNode == NULL_NODE )				mEnd = true;						return( currentNode->rec );		};				recType&	currRec()	{ return currentNode->rec; };		// Return current record.		keyType&	currKey()	{ return currentNode->key; };		// Return current key.		nodeType*	current()	{ return currentNode; };			// Return pointer to current node. Danger! Kill this and you must get a new iterator!		bool		end()		{ return( mStart && mEnd ); };		// TRUE if we've seen all nodes.	};	typedef XRBIteratorTemplate<keyType,recType>	XRBIterator;protected:	nodeType		*rootNode;	public:	XRedBlackTree();	~XRedBlackTree();		/* 	insert a new record with a given key 	multimap functionality: multiple entries with the same key _are_ supported	root may change and is returned in "root"	*/	statusEnum		insert(keyType key, recType *rec);	/*	delete the first record with this key	root may change and is returned in "root"	note that this will be the same node as first returned by find or findClosest	but not necessarily the same as any arbitrary node with this key	so if you aren't using just find and findClosest, take caution or write a delete which takes a recType param	*/	statusEnum		deleteNode(keyType key);		/*	called by deleteNode to delete the node after it's been located.	*/	statusEnum		killNode( nodeType* z );	/*	find exact match for this key, and return record	root may change and is returned in "root"	*/	statusEnum		find(keyType key, recType *rec);	/*	find "best" match for this key, and return record	"best" match is never smaller than desired key	root may change and is returned in "root"	*/	statusEnum		findClosest(keyType *key, recType *rec);		/*	delete all nodes from this tree starting at the node passed.	*/	void			killAll( nodeType* rec );		/*	same as calling killAll with Root node.	*/	void			killAll();		/*	return the number of entries in this.	*/	size_t			size();		/*	this calls the proc to which you pass a pointer once for every node.	*/	void			doForEach( doForEachProcType* proc );		/*	return iterator object that lets us walk the whole tree.	*/	XRBIterator*	first()		{ return( new XRBIterator(this) ); };		/*	called by iterator to do the actual walking.	*/	void			getNext( nodeType **current );	protected:	void	callProcForNode( nodeType* currNode, doForEachProcType* proc );	void	rotateLeft( nodeType *x);	void	rotateRight( nodeType *x);	void	insertFixup( nodeType *x);	void	deleteFixup( nodeType *x);};#endif /*XREDBLACKTREE_H*/